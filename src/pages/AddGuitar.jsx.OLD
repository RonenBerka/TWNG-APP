import { useState, useEffect, useRef, useCallback } from "react";
import { Link, useNavigate } from 'react-router-dom';
import {
  ArrowLeft, ArrowRight, Upload, Image, X, Check, ChevronDown, ChevronUp,
  Camera, Sparkles, Guitar, Calendar, FileText, Clock, Eye, GripVertical,
  Trash2, Edit3, AlertTriangle, Star, Shield, Zap, RotateCcw, Save, Loader, Info
} from "lucide-react";
import { T } from '../theme/tokens';
import { useAuth } from '../context/AuthContext';
import { supabase } from '../lib/supabase/client';
import { createGuitar } from '../lib/supabase/guitars';
import { decodeSerial, SUPPORTED_BRANDS } from '../lib/serialDecoder';
import { searchBrands, searchModels, getModelSpecs, mapCatalogToFormFields } from '../lib/supabase/guitarCatalog';

const STEPS = [
  { num: 1, label: "Photos", icon: "ðŸ“¸", required: true },
  { num: 2, label: "Basic Info", icon: "ðŸŽ¸", required: true },
  { num: 3, label: "Specs", icon: "ðŸ“‹", required: false },
  { num: 4, label: "Story", icon: "ðŸ“–", required: false },
  { num: 5, label: "Timeline", icon: "â±ï¸", required: false },
  { num: 6, label: "Review", icon: "ðŸ‘ï¸", required: true },
];

const BRANDS = [
  // Tier 1 â€” Major Brands
  "Fender", "Squier", "Gibson", "Epiphone", "Martin", "Taylor", "PRS", "Ibanez",
  "Jackson", "Charvel", "ESP", "LTD", "Schecter", "Gretsch", "Rickenbacker",
  "Yamaha", "Music Man", "Guild", "BC Rich", "Cort", "G&L",
  // Acoustic Specialists
  "Seagull", "Godin", "Art & Lutherie", "Simon & Patrick", "Norman", "Takamine",
  "Alvarez", "Washburn", "Breedlove", "LarrivÃ©e", "Collings", "Bourgeois",
  "Santa Cruz", "Lowden", "Eastman", "Blueridge", "Recording King", "Furch",
  "Sigma", "Maton", "Cole Clark", "Faith", "Tanglewood", "Crafter", "Lakewood",
  "Avalon", "Atkin", "Brook", "Fylde", "Goodall", "Huss & Dalton", "McPherson",
  "Rainsong", "Composite Acoustics", "Emerald", "Voyage-Air", "Journey",
  // Bass Specialists
  "Warwick", "Lakland", "Spector", "HÃ¶fner", "Dingwall", "Sadowsky", "Fodera",
  "MTD", "Sandberg", "Marleaux", "Pedulla", "Alembic", "Zon", "Modulus",
  "Status", "Maruszczyk", "Sire",
  // Japanese Builders
  "Tokai", "Greco", "Fujigen", "Edwards", "Bacchus", "Navigator", "Orville",
  "Burny", "Fernandes", "Grassroots", "Aria", "Teisco",
  // Boutique Electric
  "Suhr", "Tom Anderson", "Kiesel", "Knaggs", "Nik Huber", "Novo", "Fano",
  "Kauer", "Patrick James Eggle", "Vigier", "Caparison", "Mayones", "Skervesen",
  "Strandberg", "Aristides", "Ormsby", "Tyler", "Thorn", "Nash", "LSL", "Haar",
  "Melancon", "Grosh", "Asher", "RS Guitarworks", "Danocaster", "K-Line",
  // European Builders
  "Framus", "Duesenberg", "Hagstrom", "Fret-King", "Lag", "Zemaitis", "Italia",
  "Gordon Smith", "Revelation", "Burns",
  // Budget & Mainstream
  "Harley Benton", "Stagg", "Luna", "Dean", "Kramer", "Peavey", "Samick",
  "Michael Kelly", "Chapman", "Reverend", "Danelectro", "Eastwood", "Supro",
  "D'Angelico", "Benedetto", "Hamer", "Heritage", "Parker", "Solar",
  // Always last
  "Other"
];
const BODY_TYPES = ["Solid Body", "Semi-Hollow", "Hollow Body", "Acoustic", "Classical", "Bass", "12-String", "Other"];
const WOODS = ["Mahogany", "Maple", "Ash", "Alder", "Spruce", "Cedar", "Rosewood", "Padauk", "Flame Maple", "Quilted Maple", "Other"];
const FINISHES = ["Gloss Lacquer", "Satin Lacquer", "Matte Finish", "Oil Finish", "Stain", "Burst Finish", "Natural", "Other"];
const PICKUP_TYPES = ["Single Coil", "Humbucker", "P-90", "Jazzmaster", "Offset", "Lipstick", "Other"];
const BRIDGE_TYPES = ["Tune-o-matic", "Hardtail", "Tremolo", "Floyd Rose", "Jazzmaster", "Bigsby", "Other"];

// AI Backend Configuration
const ANALYZE_FUNCTION = 'analyze-guitar';
const AI_TIMEOUT_MS = 15000; // 15 second timeout for Edge Function

// Demo image for AI analysis preview
const DEMO_IMG = "/images/guitars/shopping-1.webp";

// Empty result template for fallback mode
const EMPTY_RESULT = {
  confidence: 0,
  brand: { value: "", confidence: 0 },
  model: { value: "", confidence: 0 },
  year: { value: "", confidence: 0 },
  country: { value: "", confidence: 0 },
  bodyType: { value: "", confidence: 0 },
  finish: { value: "", confidence: 0 },
  color: { value: "", confidence: 0 },
  topWood: { value: "", confidence: 0 },
  bodyWood: { value: "", confidence: 0 },
  neckWood: { value: "", confidence: 0 },
  fretboardWood: { value: "", confidence: 0 },
  neckProfile: { value: "", confidence: 0 },
  scaleLength: { value: "", confidence: 0 },
  frets: { value: "", confidence: 0 },
  pickupConfig: { value: "", confidence: 0 },
  pickups: { value: "", confidence: 0 },
  controls: { value: "", confidence: 0 },
  bridge: { value: "", confidence: 0 },
  bridgeType: { value: "", confidence: 0 },
  tuners: { value: "", confidence: 0 },
  nutMaterial: { value: "", confidence: 0 },
  hardwareFinish: { value: "", confidence: 0 },
  notes: "",
};

// Smart client-side analysis function â€” extracts info from filenames and provides intelligent defaults
const analyzeGuitarFromPhotos = (photos) => {
  const result = { ...EMPTY_RESULT };

  // Extract clues from filenames (e.g., "fender-strat.jpg" â†’ brand: Fender, model: Stratocaster)
  const filenamesLower = photos.map(p => p.file.name.toLowerCase()).join(" ");

  // Brand detection from filename
  const brandMap = {
    'fender': 'Fender', 'squier': 'Squier', 'gibson': 'Gibson', 'epiphone': 'Epiphone',
    'martin': 'Martin', 'taylor': 'Taylor', 'prs': 'PRS', 'ibanez': 'Ibanez',
    'jackson': 'Jackson', 'esp': 'ESP', 'ltd': 'LTD', 'schecter': 'Schecter',
    'gretsch': 'Gretsch', 'rickenbacker': 'Rickenbacker', 'yamaha': 'Yamaha',
    'g&l': 'G&L', 'heritage': 'Heritage', 'charvel': 'Charvel',
  };

  // Model detection patterns
  const modelPatterns = {
    'strat': 'Stratocaster', 'telecaster': 'Telecaster', 'jazzmaster': 'Jazzmaster',
    'les paul': 'Les Paul', 'sg': 'SG', 'explorer': 'Explorer',
    '335': 'ES-335', '339': 'ES-339', '355': 'ES-355',
    'p bass': 'Precision Bass', 'j bass': 'Jazz Bass',
  };

  // Try to detect brand
  for (const [key, brand] of Object.entries(brandMap)) {
    if (filenamesLower.includes(key)) {
      result.brand = { value: brand, confidence: 0.5 };
      break;
    }
  }

  // Try to detect model
  for (const [key, model] of Object.entries(modelPatterns)) {
    if (filenamesLower.includes(key)) {
      result.model = { value: model, confidence: 0.4 };
      break;
    }
  }

  // Return smart analysis (not a demo)
  return result;
};

const AI_RESULT = {
  confidence: 0.94,
  brand: { value: "Heritage", confidence: 0.97 },
  model: { value: "H-150 Standard", confidence: 0.92 },
  year: { value: "2020-2024", confidence: 0.78 },
  country: { value: "USA", confidence: 0.95 },
  bodyType: { value: "Solid Body", confidence: 0.99 },
  finish: { value: "Honey Burst", confidence: 0.88 },
  color: { value: "Honey Burst", confidence: 0.88 },
  topWood: { value: "Flame Maple", confidence: 0.85 },
  bodyWood: { value: "Mahogany", confidence: 0.90 },
  neckWood: { value: "Mahogany", confidence: 0.85 },
  fretboardWood: { value: "Rosewood", confidence: 0.85 },
  neckProfile: { value: "Rounded C", confidence: 0.70 },
  scaleLength: { value: "24.75", confidence: 0.95 },
  frets: { value: "22", confidence: 0.90 },
  pickupConfig: { value: "HH", confidence: 0.95 },
  pickups: { value: "Heritage PAF Humbuckers", confidence: 0.83 },
  controls: { value: "2V 2T 3-way toggle", confidence: 0.85 },
  bridge: { value: "TonePros ABR-1", confidence: 0.75 },
  bridgeType: { value: "Tune-o-matic", confidence: 0.90 },
  tuners: { value: "Kluson-style", confidence: 0.70 },
  nutMaterial: { value: "Bone", confidence: 0.65 },
  hardwareFinish: { value: "Nickel", confidence: 0.80 },
  notes: "Demo mode â€” deploy the Edge Function for real AI identification.",
};

// ============================================================
// SHARED COMPONENTS
// ============================================================
function Badge({ children, variant = "default" }) {
  const v = {
    default: { background: T.borderAcc + "33", color: T.amber, border: `1px solid ${T.borderAcc}` },
    outline: { background: "transparent", color: T.txt2, border: `1px solid ${T.border}` },
    active: { background: T.warm, color: T.bgDeep, border: `1px solid ${T.warm}` },
    verified: { background: "#065F4620", color: "#34D399", border: "1px solid #065F4640" },
    high: { background: "#065F4620", color: "#34D399", border: "1px solid #065F4640" },
    medium: { background: "#92400E20", color: T.amber, border: `1px solid ${T.borderAcc}` },
    low: { background: "#7F1D1D20", color: "#F87171", border: "1px solid #7F1D1D40" },
  };
  const style = v[variant] || v.default;
  return (
    <span style={{
      ...style,
      padding: "4px 12px", borderRadius: "9999px", fontSize: "11px",
      fontFamily: "'JetBrains Mono', monospace", fontWeight: 500,
      display: "inline-flex", alignItems: "center", gap: "4px", whiteSpace: "nowrap"
    }}>
      {children}
    </span>
  );
}

function FormField({ label, required, hint, children }) {
  return (
    <div style={{ marginBottom: "20px" }}>
      <label style={{ display: "block", fontSize: "13px", fontWeight: 600, color: T.txt, marginBottom: "6px" }}>
        {label} {required && <span style={{ color: T.warm }}>*</span>}
      </label>
      {hint && <p style={{ fontSize: "12px", color: T.txtM, marginBottom: "8px" }}>{hint}</p>}
      {children}
    </div>
  );
}

function TextInput({ value, onChange, placeholder, ...props }) {
  return (
    <input
      value={value} onChange={onChange} placeholder={placeholder}
      style={{
        width: "100%", padding: "10px 14px", borderRadius: "10px",
        background: T.bgCard, border: `1px solid ${T.border}`, color: T.txt, fontSize: "14px",
        outline: "none", transition: "border-color 0.2s", ...props.style
      }}
      onFocus={e => e.target.style.borderColor = T.borderAcc}
      onBlur={e => e.target.style.borderColor = T.border}
    />
  );
}

function SelectInput({ value, onChange, options, placeholder }) {
  return (
    <select
      value={value} onChange={onChange}
      style={{
        width: "100%", padding: "10px 14px", borderRadius: "10px",
        background: T.bgCard, border: `1px solid ${T.border}`,
        color: value ? T.txt : T.txtM, fontSize: "14px", outline: "none", cursor: "pointer", appearance: "none"
      }}
    >
      <option value="" style={{ color: T.txtM }}>{placeholder}</option>
      {options.map(o => <option key={o} value={o}>{o}</option>)}
    </select>
  );
}

function AutocompleteInput({ value, onChange, onSelect, fetchSuggestions, placeholder, renderItem, debounceMs = 250, disabled = false, searchOnFocus = false }) {
  const [suggestions, setSuggestions] = useState([]);
  const [showDropdown, setShowDropdown] = useState(false);
  const [highlightIdx, setHighlightIdx] = useState(-1);
  const [loading, setLoading] = useState(false);
  const timerRef = useRef(null);
  const containerRef = useRef(null);
  const inputRef = useRef(null);

  // Close dropdown on outside click
  useEffect(() => {
    const handleClick = (e) => {
      if (containerRef.current && !containerRef.current.contains(e.target)) {
        setShowDropdown(false);
      }
    };
    document.addEventListener("mousedown", handleClick);
    return () => document.removeEventListener("mousedown", handleClick);
  }, []);

  const doSearch = useCallback(async (query) => {
    if (!fetchSuggestions) return;
    setLoading(true);
    try {
      const results = await fetchSuggestions(query);
      setSuggestions(results || []);
      setShowDropdown((results || []).length > 0);
      setHighlightIdx(-1);
    } catch {
      setSuggestions([]);
    } finally {
      setLoading(false);
    }
  }, [fetchSuggestions]);

  const handleInputChange = (e) => {
    const val = e.target.value;
    onChange(val);
    clearTimeout(timerRef.current);
    if (val.length >= 1) {
      timerRef.current = setTimeout(() => doSearch(val), debounceMs);
    } else {
      setSuggestions([]);
      setShowDropdown(false);
    }
  };

  const handleSelect = (item) => {
    setShowDropdown(false);
    setHighlightIdx(-1);
    onSelect && onSelect(item);
  };

  const handleKeyDown = (e) => {
    if (!showDropdown || suggestions.length === 0) return;
    if (e.key === "ArrowDown") {
      e.preventDefault();
      setHighlightIdx(i => Math.min(i + 1, suggestions.length - 1));
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      setHighlightIdx(i => Math.max(i - 1, 0));
    } else if (e.key === "Enter" && highlightIdx >= 0) {
      e.preventDefault();
      handleSelect(suggestions[highlightIdx]);
    } else if (e.key === "Escape") {
      setShowDropdown(false);
    }
  };

  const handleFocus = () => {
    if (searchOnFocus && (!value || value.length === 0)) {
      doSearch('');
    } else if (value && value.length >= 1 && suggestions.length > 0) {
      setShowDropdown(true);
    } else if (value && value.length >= 1) {
      doSearch(value);
    }
  };

  return (
    <div ref={containerRef} style={{ position: "relative" }}>
      <div style={{ position: "relative" }}>
        <input
          ref={inputRef}
          value={value}
          onChange={handleInputChange}
          onKeyDown={handleKeyDown}
          onFocus={handleFocus}
          placeholder={placeholder}
          disabled={disabled}
          style={{
            width: "100%", padding: "10px 14px", paddingRight: loading ? "36px" : "14px",
            borderRadius: "10px", background: T.bgCard,
            border: `1px solid ${showDropdown ? T.borderAcc : T.border}`,
            color: T.txt, fontSize: "14px", outline: "none", transition: "border-color 0.2s"
          }}
          onBlur={(e) => {
            // Delay to allow click on dropdown item
            setTimeout(() => {
              if (containerRef.current && !containerRef.current.contains(document.activeElement)) {
                setShowDropdown(false);
              }
            }, 200);
          }}
        />
        {loading && (
          <div style={{
            position: "absolute", right: "12px", top: "50%", transform: "translateY(-50%)",
            width: "16px", height: "16px", borderRadius: "50%",
            border: `2px solid ${T.border}`, borderTopColor: T.warm,
            animation: "spin 0.8s linear infinite"
          }} />
        )}
      </div>
      {showDropdown && suggestions.length > 0 && (
        <div style={{
          position: "absolute", top: "100%", left: 0, right: 0, zIndex: 50,
          marginTop: "4px", background: T.bgElev, border: `1px solid ${T.borderAcc}`,
          borderRadius: "10px", boxShadow: "0 8px 24px rgba(0,0,0,0.3)",
          maxHeight: "240px", overflowY: "auto"
        }}>
          {suggestions.map((item, idx) => (
            <div
              key={idx}
              onMouseDown={(e) => { e.preventDefault(); handleSelect(item); }}
              onMouseEnter={() => setHighlightIdx(idx)}
              style={{
                padding: "10px 14px", cursor: "pointer",
                background: idx === highlightIdx ? T.warm + "15" : "transparent",
                borderBottom: idx < suggestions.length - 1 ? `1px solid ${T.border}20` : "none",
                transition: "background 0.15s"
              }}
            >
              {renderItem ? renderItem(item, idx === highlightIdx) : (
                <span style={{ color: T.txt, fontSize: "14px" }}>
                  {typeof item === "string" ? item : item.label || item.model || JSON.stringify(item)}
                </span>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

function TextArea({ value, onChange, placeholder, rows = 4 }) {
  return (
    <textarea
      value={value} onChange={onChange} placeholder={placeholder} rows={rows}
      style={{
        width: "100%", padding: "12px 14px", borderRadius: "10px",
        background: T.bgCard, border: `1px solid ${T.border}`, color: T.txt, fontSize: "14px",
        outline: "none", resize: "vertical", lineHeight: 1.5, fontFamily: "'DM Sans', sans-serif"
      }}
      onFocus={e => e.target.style.borderColor = T.borderAcc}
      onBlur={e => e.target.style.borderColor = T.border}
    />
  );
}

function Button({ children, variant = "primary", onClick, disabled = false, ...props }) {
  const v = {
    primary: { background: T.warm, color: T.bgDeep, border: "none" },
    secondary: { background: "transparent", color: T.txt, border: `1px solid ${T.border}` },
    ghost: { background: "transparent", color: T.txt2, border: "none" },
  };
  return (
    <button
      onClick={onClick} disabled={disabled}
      style={{
        padding: "10px 18px", borderRadius: "10px", fontSize: "13px", fontWeight: 600,
        cursor: disabled ? "not-allowed" : "pointer", opacity: disabled ? 0.5 : 1,
        transition: "all 0.2s", ...v[variant], ...props.style
      }}
    >
      {children}
    </button>
  );
}

function ProgressBar({ currentStep }) {
  return (
    <div style={{ display: "flex", gap: "4px", alignItems: "center" }} className="progress-bar">
      {STEPS.map((s, i) => (
        <div key={i} style={{ display: "flex", alignItems: "center", gap: "4px", flex: 1 }} className="progress-step">
          <div style={{
            width: "28px", height: "28px", borderRadius: "50%", display: "flex",
            alignItems: "center", justifyContent: "center", flexShrink: 0,
            background: i + 1 < currentStep ? T.warm : i + 1 === currentStep ? T.warm + "20" : "transparent",
            border: `2px solid ${i + 1 <= currentStep ? T.warm : T.border}`,
            color: i + 1 < currentStep ? T.bgDeep : i + 1 === currentStep ? T.warm : T.txtM,
            fontSize: "11px", fontWeight: 700, transition: "all 0.3s"
          }} className="progress-bar-number">
            {i + 1 < currentStep ? <Check size={14} strokeWidth={3} /> : i + 1}
          </div>
          {i < STEPS.length - 1 && (
            <div style={{
              flex: 1, height: "2px",
              background: i + 1 < currentStep ? T.warm : T.border,
              transition: "background 0.3s", borderRadius: "1px"
            }} className="progress-connector" />
          )}
        </div>
      ))}
    </div>
  );
}

function ConfidenceMeter({ value, size = "default" }) {
  const pct = Math.round(value * 100);
  const color = pct >= 85 ? "#34D399" : pct >= 70 ? T.amber : "#F87171";
  const label = pct >= 85 ? "High" : pct >= 70 ? "Medium" : "Low";
  const variant = pct >= 85 ? "high" : pct >= 70 ? "medium" : "low";

  if (size === "large") {
    return (
      <div style={{ display: "flex", alignItems: "center", gap: "16px" }}>
        <div style={{ position: "relative", width: "80px", height: "80px" }}>
          <svg width="80" height="80" style={{ transform: "rotate(-90deg)" }}>
            <circle cx="40" cy="40" r="32" fill="none" stroke={T.border} strokeWidth="4" />
            <circle cx="40" cy="40" r="32" fill="none" stroke={color} strokeWidth="4"
              strokeDasharray={`${pct * 2.01} 201`} strokeLinecap="round" />
          </svg>
          <span style={{
            position: "absolute", inset: 0, display: "flex", alignItems: "center", justifyContent: "center",
            fontFamily: "'JetBrains Mono', monospace", fontSize: "18px", fontWeight: 700, color
          }}>
            {pct}%
          </span>
        </div>
        <div>
          <p style={{ fontWeight: 600, color: T.txt, fontSize: "16px" }}>Overall Confidence</p>
          <Badge variant={variant}>{label} confidence</Badge>
        </div>
      </div>
    );
  }

  return (
    <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
      <div style={{ width: "40px", height: "4px", borderRadius: "2px", background: T.border, overflow: "hidden" }}>
        <div style={{ width: `${pct}%`, height: "100%", background: color, borderRadius: "2px" }} />
      </div>
      <span style={{ fontFamily: "'JetBrains Mono', monospace", fontSize: "11px", color }}>{pct}%</span>
    </div>
  );
}

// ============================================================
// PAGE 1: ADD GUITAR (MANUAL) - MULTI-STEP FORM
// ============================================================
function StepPhotos({ photos, setPhotos }) {
  const fileInputRef = useRef(null);
  const [dragActive, setDragActive] = useState(false);

  const handleFiles = (files) => {
    const validFiles = Array.from(files).filter(f => {
      if (!f.type.match(/^image\/(jpeg|png|webp|gif)$/)) return false;
      if (f.size > 10 * 1024 * 1024) return false; // 10MB limit
      return true;
    });
    if (validFiles.length === 0) return;

    const newPhotos = validFiles.map(file => ({
      file,
      preview: URL.createObjectURL(file),
    }));
    setPhotos([...photos, ...newPhotos].slice(0, 20));
  };

  const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); setDragActive(true); };
  const handleDragLeave = (e) => { e.preventDefault(); e.stopPropagation(); setDragActive(false); };
  const handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      handleFiles(e.dataTransfer.files);
    }
  };

  return (
    <div>
      <h2 style={{ fontFamily: "'Playfair Display', serif", fontSize: "28px", fontWeight: 600, color: T.txt, marginBottom: "8px" }}>
        Upload Photos
      </h2>
      <p style={{ color: T.txt2, marginBottom: "28px", fontSize: "15px" }}>
        Add 1-20 images of your guitar. The first image becomes the cover.
      </p>

      {/* Hidden file input */}
      <input
        ref={fileInputRef}
        type="file"
        accept="image/jpeg,image/png,image/webp,image/gif"
        multiple
        style={{ display: 'none' }}
        onChange={(e) => {
          if (e.target.files && e.target.files.length > 0) handleFiles(e.target.files);
          e.target.value = ''; // reset so the same file can be re-selected
        }}
      />

      {/* Upload zone â€” click or drag */}
      <div
        onClick={() => fileInputRef.current?.click()}
        onDragOver={handleDragOver}
        onDragEnter={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        style={{
          border: `2px dashed ${dragActive ? T.warm : T.border}`, borderRadius: "16px", padding: "56px 24px", textAlign: "center",
          cursor: "pointer", background: dragActive ? T.warm + "08" : T.bgCard, transition: "all 0.2s", marginBottom: "24px"
        }}
        className="upload-zone"
        onMouseEnter={e => { if (!dragActive) { e.currentTarget.style.borderColor = T.warm; e.currentTarget.style.background = T.warm + "08"; }}}
        onMouseLeave={e => { if (!dragActive) { e.currentTarget.style.borderColor = T.border; e.currentTarget.style.background = T.bgCard; }}}
      >
        <Camera size={48} style={{ color: dragActive ? T.warm : T.txtM, marginBottom: "16px" }} />
        <p style={{ color: T.txt, fontWeight: 600, marginBottom: "6px", fontSize: "15px" }}>
          {dragActive ? "Drop photos here" : "Drag photos or click to upload"}
        </p>
        <p style={{ fontSize: "13px", color: T.txtM }}>JPG, PNG, WebP Â· Max 10MB per image Â· {photos.length}/20</p>
      </div>

      {/* Photo grid */}
      {photos.length > 0 && (
        <div style={{ display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(140px, 1fr))", gap: "12px" }}>
          {photos.map((p, i) => (
            <div
              key={i}
              style={{
                position: "relative", aspectRatio: "1", borderRadius: "12px", overflow: "hidden",
                border: `2px solid ${i === 0 ? T.warm : T.border}`
              }}
            >
              <img src={p.preview} alt={`Guitar ${i + 1}`} style={{ width: "100%", height: "100%", objectFit: "cover" }} />
              {i === 0 && (
                <div style={{ position: "absolute", top: "8px", left: "8px" }}>
                  <Badge variant="verified"><Star size={10} style={{ display: "inline", marginRight: "2px" }} />Cover</Badge>
                </div>
              )}
              <button
                onClick={e => { e.stopPropagation(); setPhotos(photos.filter((_, j) => j !== i)); }}
                style={{
                  position: "absolute", top: "8px", right: "8px", width: "24px", height: "24px",
                  borderRadius: "50%", background: T.bgDeep + "B0", border: `1px solid ${T.border}`,
                  color: T.txt, display: "flex", alignItems: "center", justifyContent: "center", cursor: "pointer"
                }}
              >
                <X size={12} />
              </button>
              <div style={{ position: "absolute", bottom: "8px", left: "8px", color: T.txtM, cursor: "grab" }}>
                <GripVertical size={14} />
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

function StepBasicInfo({ data, setData, onSerialResult, onAutoFill }) {
  const [serialResult, setSerialResult] = useState(null);
  const [decoding, setDecoding] = useState(false);
  const [autoFillInfo, setAutoFillInfo] = useState(null); // Shows what was auto-filled

  // Brand autocomplete: search catalog + fallback to BRANDS constant
  const fetchBrandSuggestions = useCallback(async (query) => {
    // Search catalog first
    const catalogBrands = await searchBrands(query);

    // Also filter local BRANDS list for anything not in catalog
    const localMatches = BRANDS.filter(b =>
      b.toLowerCase().startsWith(query.toLowerCase()) &&
      !catalogBrands.some(cb => cb.toLowerCase() === b.toLowerCase())
    );

    // Merge: catalog brands first (they have full data), then local-only brands
    const merged = [
      ...catalogBrands.map(b => ({ name: b, hasCatalog: true })),
      ...localMatches.slice(0, 10).map(b => ({ name: b, hasCatalog: false })),
    ];
    return merged.slice(0, 15);
  }, []);

  // Model autocomplete: search catalog for the selected brand
  const fetchModelSuggestions = useCallback(async (query) => {
    if (!data.brand) return [];
    const models = await searchModels(data.brand, query);
    return models;
  }, [data.brand]);

  // Handle brand selection from autocomplete
  const handleBrandSelect = (item) => {
    const brandName = typeof item === "string" ? item : item.name;
    setData(prev => ({ ...prev, brand: brandName, model: "" }));
    setAutoFillInfo(null);
  };

  // Handle model selection â€” fetch full specs and auto-fill
  const handleModelSelect = async (item) => {
    const modelName = typeof item === "string" ? item : item.model;
    setData(prev => ({ ...prev, model: modelName }));

    // Fetch full specs from catalog
    const specs = await getModelSpecs(data.brand, modelName);
    if (specs) {
      const mapped = mapCatalogToFormFields(specs);

      // Only fill fields that are currently empty
      setData(prev => {
        const updated = { ...prev, model: modelName };
        const filled = [];

        for (const [key, val] of Object.entries(mapped)) {
          if (key.startsWith('_')) continue; // Skip internal fields
          if (!prev[key] || prev[key] === "") {
            updated[key] = val;
            filled.push(key);
          }
        }

        if (filled.length > 0) {
          setAutoFillInfo({ fields: filled, specs: mapped });
        }

        return updated;
      });

      // Notify parent about auto-fill
      onAutoFill && onAutoFill(specs);
    }
  };

  const handleDecodeSerial = async () => {
    if (!data.serialNumber) return;
    setDecoding(true);
    try {
      const result = decodeSerial(data.serialNumber, data.brand || undefined);
      setSerialResult(result);
      onSerialResult && onSerialResult(result);

      // Auto-fill year if successful and year is empty
      if (result.success && result.decoded?.year && !data.year) {
        const yr = result.decoded.year.toString();
        setData(prev => ({ ...prev, year: yr }));
      }

      // Auto-fill brand if matches SUPPORTED_BRANDS and brand is empty
      if (result.success && result.decoded?.brand && !data.brand && SUPPORTED_BRANDS.includes(result.decoded.brand)) {
        const br = result.decoded.brand;
        setData(prev => ({ ...prev, brand: br }));
      }
    } catch (err) {
      console.error('Decode error:', err);
      const failResult = { success: false, explanation: 'Error decoding serial number' };
      setSerialResult(failResult);
      onSerialResult && onSerialResult(failResult);
    } finally {
      setDecoding(false);
    }
  };

  // Map field keys to readable labels
  const fieldLabels = {
    year: "Year", bodyType: "Body Type", bodyWood: "Body Wood", topWood: "Top Wood",
    neckWood: "Neck Wood", fretboardWood: "Fretboard", neckProfile: "Neck Profile",
    scaleLength: "Scale Length", frets: "Frets", pickupConfig: "Pickup Config",
    pickups: "Pickups", bridgeType: "Bridge Type", bridgeModel: "Bridge", tuners: "Tuners",
    nutMaterial: "Nut", hardwareFinish: "Hardware", country: "Country", finish: "Finish",
    color: "Color"
  };

  return (
    <div>
      <h2 style={{ fontFamily: "'Playfair Display', serif", fontSize: "28px", fontWeight: 600, color: T.txt, marginBottom: "8px" }}>
        Basic Information
      </h2>
      <p style={{ color: T.txt2, marginBottom: "28px", fontSize: "15px" }}>
        Tell us the fundamentals about your guitar.
      </p>

      <FormField label="Brand" required>
        <AutocompleteInput
          value={data.brand}
          onChange={(val) => setData(prev => ({ ...prev, brand: val }))}
          onSelect={handleBrandSelect}
          fetchSuggestions={fetchBrandSuggestions}
          placeholder="Start typing a brand..."
          renderItem={(item, highlighted) => (
            <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between" }}>
              <span style={{ color: T.txt, fontSize: "14px", fontWeight: highlighted ? 600 : 400 }}>
                {item.name}
              </span>
              {item.hasCatalog && (
                <span style={{
                  fontSize: "10px", color: T.warm, background: T.warm + "15",
                  padding: "2px 8px", borderRadius: "9999px", fontWeight: 500,
                  fontFamily: "'JetBrains Mono', monospace"
                }}>
                  Specs available
                </span>
              )}
            </div>
          )}
        />
      </FormField>

      <FormField label="Model" required hint="e.g., SG Standard, Stratocaster">
        <AutocompleteInput
          value={data.model}
          onChange={(val) => setData(prev => ({ ...prev, model: val }))}
          onSelect={handleModelSelect}
          fetchSuggestions={fetchModelSuggestions}
          placeholder={data.brand ? `Search ${data.brand} models...` : "Select a brand first..."}
          disabled={!data.brand}
          searchOnFocus={true}
          renderItem={(item, highlighted) => (
            <div>
              <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
                <span style={{ color: T.txt, fontSize: "14px", fontWeight: highlighted ? 600 : 400 }}>
                  {item.model}
                </span>
                {item.body_style && (
                  <span style={{ fontSize: "11px", color: T.txtM }}>
                    {item.body_style}
                  </span>
                )}
              </div>
              {item.year_range && (
                <span style={{ fontSize: "11px", color: T.txt2, fontFamily: "'JetBrains Mono', monospace" }}>
                  {item.year_range}
                </span>
              )}
            </div>
          )}
        />
      </FormField>

      {/* Auto-fill notification */}
      {autoFillInfo && (
        <div style={{
          marginBottom: "20px", padding: "12px 14px", borderRadius: "10px",
          border: `1px solid ${T.warm}30`, background: T.warm + "08"
        }}>
          <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
            <Sparkles size={14} style={{ color: T.warm }} />
            <span style={{ fontSize: "13px", fontWeight: 600, color: T.warm }}>
              Specs auto-filled from catalog
            </span>
          </div>
          <div style={{ display: "flex", flexWrap: "wrap", gap: "6px" }}>
            {autoFillInfo.fields.filter(f => !f.startsWith('_')).map(f => (
              <span key={f} style={{
                fontSize: "11px", padding: "3px 8px", borderRadius: "6px",
                background: T.bgCard, border: `1px solid ${T.border}`, color: T.txt2,
                fontFamily: "'JetBrains Mono', monospace"
              }}>
                {fieldLabels[f] || f}
              </span>
            ))}
          </div>
          <button
            onClick={() => {
              // Undo auto-fill â€” clear the fields that were auto-filled
              setData(prev => {
                const reset = { ...prev };
                autoFillInfo.fields.forEach(f => { if (!f.startsWith('_')) reset[f] = ""; });
                return reset;
              });
              setAutoFillInfo(null);
            }}
            style={{
              marginTop: "8px", padding: "4px 10px", borderRadius: "6px",
              background: "transparent", border: `1px solid ${T.border}`,
              color: T.txtM, fontSize: "11px", cursor: "pointer",
              display: "inline-flex", alignItems: "center", gap: "4px"
            }}
          >
            <RotateCcw size={10} /> Undo auto-fill
          </button>
        </div>
      )}

      <FormField label="Year" hint="Approximate year of manufacture">
        <TextInput
          value={data.year} onChange={e => setData({ ...data, year: e.target.value })}
          placeholder="e.g., 2015" type="number"
        />
      </FormField>

      <FormField label="Serial Number" hint="Found on headstock or body">
        <div style={{ display: "flex", gap: "8px", alignItems: "flex-end" }}>
          <TextInput
            value={data.serialNumber} onChange={e => {
              setData({ ...data, serialNumber: e.target.value });
              setSerialResult(null);
            }}
            placeholder="e.g., 12345678"
            style={{ flex: 1 }}
          />
          <Button
            variant="secondary"
            onClick={handleDecodeSerial}
            disabled={!data.serialNumber || decoding}
            style={{ padding: "10px 14px", whiteSpace: "nowrap" }}
          >
            {decoding ? <Loader size={14} style={{ display: "inline", animation: "spin 1s linear infinite" }} /> : "Decode"}
          </Button>
        </div>

        {/* Decode result display */}
        {serialResult && (
          <div style={{
            marginTop: "12px",
            padding: "12px 14px",
            borderRadius: "10px",
            border: `1px solid ${serialResult.success ? "#34D39940" : "#F8717140"}`,
            background: serialResult.success ? "#34D39915" : "#F8717115"
          }}>
            {serialResult.success ? (
              <>
                <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }}>
                  <Badge variant={
                    serialResult.confidence === 'high' ? 'verified' :
                    serialResult.confidence === 'medium' ? 'medium' : 'low'
                  }>
                    {serialResult.confidence === 'high' && 'High confidence'}
                    {serialResult.confidence === 'medium' && 'Medium confidence'}
                    {serialResult.confidence === 'low' && 'Low confidence'}
                  </Badge>
                  {serialResult.decoded?.brand && (
                    <Badge variant="verified">{serialResult.decoded.brand}</Badge>
                  )}
                </div>
                <div style={{ fontSize: "13px", color: T.txt2, lineHeight: 1.6 }}>
                  {serialResult.decoded?.year && (
                    <div><span style={{ color: T.txtM }}>Year:</span> <span style={{ color: T.txt, fontWeight: 500 }}>{serialResult.decoded.year}</span></div>
                  )}
                  {serialResult.decoded?.yearRange && (
                    <div><span style={{ color: T.txtM }}>Year Range:</span> <span style={{ color: T.txt, fontWeight: 500 }}>{serialResult.decoded.yearRange}</span></div>
                  )}
                  {serialResult.decoded?.factory && (
                    <div><span style={{ color: T.txtM }}>Factory:</span> <span style={{ color: T.txt, fontWeight: 500 }}>{serialResult.decoded.factory}</span></div>
                  )}
                  {serialResult.decoded?.country && (
                    <div><span style={{ color: T.txtM }}>Country:</span> <span style={{ color: T.txt, fontWeight: 500 }}>{serialResult.decoded.country}</span></div>
                  )}
                  {serialResult.decoded?.series && (
                    <div><span style={{ color: T.txtM }}>Series:</span> <span style={{ color: T.txt, fontWeight: 500 }}>{serialResult.decoded.series}</span></div>
                  )}
                </div>
                {serialResult.tips && serialResult.tips.length > 0 && (
                  <div style={{ fontSize: "12px", color: T.txtM, marginTop: "8px", paddingTop: "8px", borderTop: `1px solid ${T.border}` }}>
                    <p style={{ margin: "0 0 4px", fontWeight: 600 }}>Tips:</p>
                    {serialResult.tips.map((tip, i) => (
                      <p key={i} style={{ margin: "2px 0" }}>â€¢ {tip}</p>
                    ))}
                  </div>
                )}
              </>
            ) : (
              <div style={{ display: "flex", alignItems: "flex-start", gap: "8px" }}>
                <AlertTriangle size={14} style={{ color: T.txtM, marginTop: "2px", flexShrink: 0 }} />
                <div style={{ fontSize: "13px", color: T.txt2 }}>
                  <p style={{ margin: "0 0 4px" }}>Could not decode serial number</p>
                  <p style={{ margin: 0, fontSize: "12px", color: T.txtM }}>Verify the format is correct, or try a different brand.</p>
                </div>
              </div>
            )}
          </div>
        )}
      </FormField>

      <FormField label="Country of Origin">
        <SelectInput
          value={data.country} onChange={e => setData({ ...data, country: e.target.value })}
          options={["USA", "Japan", "Indonesia", "Mexico", "South Korea", "China", "Germany", "Other"]}
          placeholder="Select origin..."
        />
      </FormField>
    </div>
  );
}

function StepSpecs({ data, setData }) {
  const [expandedGroup, setExpandedGroup] = useState("body");

  const toggleGroup = (group) => {
    setExpandedGroup(expandedGroup === group ? null : group);
  };

  const SpecGroup = ({ title, icon, children }) => (
    <div style={{ marginBottom: "16px", border: `1px solid ${T.border}`, borderRadius: "12px", overflow: "hidden" }}>
      <div
        onClick={() => toggleGroup(title.toLowerCase())}
        style={{
          display: "flex", alignItems: "center", gap: "12px", padding: "14px 16px",
          background: T.bgCard, cursor: "pointer", transition: "all 0.2s"
        }}
        onMouseEnter={e => e.currentTarget.style.background = T.bgElev}
        onMouseLeave={e => e.currentTarget.style.background = T.bgCard}
      >
        <span style={{ fontSize: "16px" }}>{icon}</span>
        <span style={{ flex: 1, fontWeight: 600, fontSize: "14px", color: T.txt }}>{title}</span>
        <ChevronDown
          size={16} style={{
            color: T.txtM, transition: "transform 0.2s",
            transform: expandedGroup === title.toLowerCase() ? "rotate(180deg)" : "rotate(0deg)"
          }}
        />
      </div>
      {expandedGroup === title.toLowerCase() && (
        <div style={{ padding: "16px", borderTop: `1px solid ${T.border}`, background: T.bgDeep }}>
          {children}
        </div>
      )}
    </div>
  );

  return (
    <div>
      <h2 style={{ fontFamily: "'Playfair Display', serif", fontSize: "28px", fontWeight: 600, color: T.txt, marginBottom: "8px" }}>
        Specifications
      </h2>
      <p style={{ color: T.txt2, marginBottom: "28px", fontSize: "15px" }}>
        Details about your guitar's construction and features.
      </p>

      <SpecGroup title="Body" icon="ðŸŽ¸">
        <FormField label="Body Type" hint="Shape of the guitar body">
          <SelectInput
            value={data.bodyType} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, bodyType: v })); }}
            options={BODY_TYPES} placeholder="Select type..."
          />
        </FormField>
        <FormField label="Body Wood" hint="Primary wood used">
          <SelectInput
            value={data.bodyWood} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, bodyWood: v })); }}
            options={WOODS} placeholder="Select wood..."
          />
        </FormField>
        <FormField label="Top Wood" hint="Top veneer (if applicable)">
          <SelectInput
            value={data.topWood} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, topWood: v })); }}
            options={WOODS} placeholder="Select wood..."
          />
        </FormField>
        <FormField label="Finish">
          <SelectInput
            value={data.finish} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, finish: v })); }}
            options={FINISHES} placeholder="Select finish..."
          />
        </FormField>
        <FormField label="Color">
          <TextInput
            value={data.color} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, color: v })); }}
            placeholder="e.g., Honey Burst, Sunburst"
          />
        </FormField>
      </SpecGroup>

      <SpecGroup title="Neck" icon="ðŸ”—">
        <FormField label="Neck Wood">
          <SelectInput
            value={data.neckWood} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, neckWood: v })); }}
            options={WOODS} placeholder="Select wood..."
          />
        </FormField>
        <FormField label="Fretboard Wood">
          <SelectInput
            value={data.fretboardWood} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, fretboardWood: v })); }}
            options={["Rosewood", "Ebony", "Maple", "Pau Ferro", "Walnut", "Richlite", "Laurel", "Other"]}
            placeholder="Select wood..."
          />
        </FormField>
        <FormField label="Neck Profile">
          <TextInput
            value={data.neckProfile} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, neckProfile: v })); }}
            placeholder="e.g., C-shape, D-shape"
          />
        </FormField>
        <FormField label="Scale Length">
          <TextInput
            value={data.scaleLength} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, scaleLength: v })); }}
            placeholder="e.g., 24.75 or 25.5"
          />
        </FormField>
        <FormField label="Number of Frets">
          <TextInput
            value={data.frets} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, frets: v })); }}
            placeholder="e.g., 22 or 24" type="number"
          />
        </FormField>
      </SpecGroup>

      <SpecGroup title="Electronics" icon="âš¡">
        <FormField label="Pickup Configuration">
          <TextInput
            value={data.pickupConfig} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, pickupConfig: v })); }}
            placeholder="e.g., HH, SSS, HSS"
          />
        </FormField>
        <FormField label="Pickups">
          <TextInput
            value={data.pickups} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, pickups: v })); }}
            placeholder="e.g., Seymour Duncan SH-4 JB"
          />
        </FormField>
        <FormField label="Controls">
          <TextInput
            value={data.controls} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, controls: v })); }}
            placeholder="e.g., 2 Volume, 1 Tone"
          />
        </FormField>
        <FormField label="Wiring Modifications">
          <TextArea
            value={data.wiringMods} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, wiringMods: v })); }}
            placeholder="Describe any custom wiring..." rows={3}
          />
        </FormField>
      </SpecGroup>

      <SpecGroup title="Hardware" icon="ðŸ”§">
        <FormField label="Bridge Type">
          <SelectInput
            value={data.bridgeType} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, bridgeType: v })); }}
            options={BRIDGE_TYPES} placeholder="Select bridge type..."
          />
        </FormField>
        <FormField label="Bridge Model">
          <TextInput
            value={data.bridgeModel} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, bridgeModel: v })); }}
            placeholder="e.g., TonePros ABR-1"
          />
        </FormField>
        <FormField label="Tuners">
          <TextInput
            value={data.tuners} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, tuners: v })); }}
            placeholder="e.g., Grover Roto-Matic"
          />
        </FormField>
        <FormField label="Nut Material">
          <SelectInput
            value={data.nutMaterial} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, nutMaterial: v })); }}
            options={["Bone", "TUSQ", "Plastic", "Ivory", "Other"]} placeholder="Select material..."
          />
        </FormField>
        <FormField label="Hardware Finish">
          <SelectInput
            value={data.hardwareFinish} onChange={e => { const v = e.target.value; setData(prev => ({ ...prev, hardwareFinish: v })); }}
            options={["Chrome", "Nickel", "Gold", "Black Nickel", "Brushed Nickel", "Other"]}
            placeholder="Select finish..."
          />
        </FormField>
      </SpecGroup>
    </div>
  );
}

function VoiceRecorder({ onTranscription }) {
  const [recording, setRecording] = useState(false);
  const [transcribing, setTranscribing] = useState(false);
  const [duration, setDuration] = useState(0);
  const [error, setError] = useState(null);
  const mediaRecorderRef = useRef(null);
  const chunksRef = useRef([]);
  const timerRef = useRef(null);

  const startRecording = async () => {
    setError(null);
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mediaRecorder = new MediaRecorder(stream, {
        mimeType: MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : 'audio/mp4'
      });
      mediaRecorderRef.current = mediaRecorder;
      chunksRef.current = [];

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) chunksRef.current.push(e.data);
      };

      mediaRecorder.onstop = async () => {
        stream.getTracks().forEach(t => t.stop());
        clearInterval(timerRef.current);

        const audioBlob = new Blob(chunksRef.current, { type: mediaRecorder.mimeType });
        setTranscribing(true);

        try {
          // Convert to base64
          const reader = new FileReader();
          const base64Promise = new Promise((resolve) => {
            reader.onloadend = () => {
              const base64 = reader.result.split(',')[1];
              resolve(base64);
            };
          });
          reader.readAsDataURL(audioBlob);
          const audioBase64 = await base64Promise;

          // Call Whisper Edge Function
          const { data, error: fnError } = await supabase.functions.invoke('transcribe-audio', {
            body: { audio: audioBase64, mimeType: mediaRecorder.mimeType },
          });

          if (fnError) throw fnError;
          if (data?.error) throw new Error(data.error);

          if (data?.text) {
            onTranscription(data.text);
          }
        } catch (err) {
          console.error('Transcription error:', err);
          setError('Could not transcribe audio. You can type your story instead.');
        } finally {
          setTranscribing(false);
        }
      };

      mediaRecorder.start(1000); // collect data every second
      setRecording(true);
      setDuration(0);
      timerRef.current = setInterval(() => setDuration(d => d + 1), 1000);
    } catch (err) {
      setError('Microphone access denied. Please allow microphone access and try again.');
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current && recording) {
      mediaRecorderRef.current.stop();
      setRecording(false);
    }
  };

  const formatTime = (s) => `${Math.floor(s / 60)}:${String(s % 60).padStart(2, '0')}`;

  return (
    <div style={{
      background: T.bgCard, border: `1px solid ${recording ? T.warm : T.border}`,
      borderRadius: "12px", padding: "16px", marginBottom: "16px",
      transition: "border-color 0.3s"
    }}>
      <div style={{ display: "flex", alignItems: "center", gap: "12px" }}>
        {!recording && !transcribing && (
          <button
            onClick={startRecording}
            style={{
              width: "44px", height: "44px", borderRadius: "50%", border: "none",
              background: T.warm, color: T.bgDeep, cursor: "pointer",
              display: "flex", alignItems: "center", justifyContent: "center",
              transition: "transform 0.2s"
            }}
            onMouseEnter={e => e.currentTarget.style.transform = "scale(1.1)"}
            onMouseLeave={e => e.currentTarget.style.transform = "scale(1)"}
          >
            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
              <path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/>
            </svg>
          </button>
        )}

        {recording && (
          <button
            onClick={stopRecording}
            style={{
              width: "44px", height: "44px", borderRadius: "50%", border: "none",
              background: "#EF4444", color: "#fff", cursor: "pointer",
              display: "flex", alignItems: "center", justifyContent: "center",
              animation: "pulse 1.5s ease-in-out infinite"
            }}
          >
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <rect x="6" y="6" width="12" height="12" rx="2"/>
            </svg>
          </button>
        )}

        {transcribing && (
          <div style={{
            width: "44px", height: "44px", borderRadius: "50%",
            border: `3px solid ${T.border}`, borderTopColor: T.warm,
            animation: "spin 0.8s linear infinite"
          }} />
        )}

        <div style={{ flex: 1 }}>
          {!recording && !transcribing && (
            <p style={{ fontSize: "13px", color: T.txt2 }}>
              Tell your guitar's story â€” we'll transcribe it for you
            </p>
          )}
          {recording && (
            <div>
              <p style={{ fontSize: "13px", color: T.warm, fontWeight: 600 }}>Recording...</p>
              <p style={{ fontSize: "12px", color: T.txtM, fontFamily: "'JetBrains Mono', monospace" }}>
                {formatTime(duration)} {duration >= 120 && " (max 5 min)"}
              </p>
            </div>
          )}
          {transcribing && (
            <p style={{ fontSize: "13px", color: T.txt2, fontWeight: 500 }}>Transcribing with Whisper AI...</p>
          )}
        </div>
      </div>

      {error && (
        <p style={{ fontSize: "12px", color: "#F87171", marginTop: "8px" }}>
          <AlertTriangle size={12} style={{ display: "inline", marginRight: "4px", verticalAlign: "text-bottom" }} />
          {error}
        </p>
      )}

      <style>{`@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }`}</style>
    </div>
  );
}

function StepStory({ data, setData }) {
  const charCount = data.description.length;

  const handleTranscription = (text) => {
    // Append transcribed text to existing description
    const separator = data.description.length > 0 ? '\n\n' : '';
    setData({ ...data, description: data.description + separator + text });
  };

  return (
    <div>
      <h2 style={{ fontFamily: "'Playfair Display', serif", fontSize: "28px", fontWeight: 600, color: T.txt, marginBottom: "8px" }}>
        Guitar Story
      </h2>
      <p style={{ color: T.txt2, marginBottom: "28px", fontSize: "15px" }}>
        Share the unique story and personality of your guitar. Type it out or use voice recording.
      </p>

      <FormField label="Nickname" hint="Give your guitar a name">
        <TextInput
          value={data.nickname} onChange={e => setData({ ...data, nickname: e.target.value })}
          placeholder="e.g., The Beauty, Golden One"
        />
      </FormField>

      <FormField label="Description" hint="How did you acquire this guitar? What makes it special?">
        {/* Voice recorder */}
        <VoiceRecorder onTranscription={handleTranscription} />

        <div style={{ position: "relative" }}>
          <TextArea
            value={data.description} onChange={e => setData({ ...data, description: e.target.value })}
            placeholder="Tell the story of your guitar... or use the mic above to dictate it" rows={6}
          />
          <p style={{ fontSize: "12px", color: T.txtM, marginTop: "6px", textAlign: "right" }}>
            {charCount} / 2000 characters
          </p>
        </div>
      </FormField>
    </div>
  );
}

function StepTimeline({ data, setData }) {
  const addEvent = () => {
    setData({
      ...data,
      events: [...data.events, { type: "", date: "", description: "" }]
    });
  };

  const updateEvent = (idx, field, value) => {
    const updated = [...data.events];
    updated[idx] = { ...updated[idx], [field]: value };
    setData({ ...data, events: updated });
  };

  const deleteEvent = (idx) => {
    setData({ ...data, events: data.events.filter((_, i) => i !== idx) });
  };

  return (
    <div>
      <h2 style={{ fontFamily: "'Playfair Display', serif", fontSize: "28px", fontWeight: 600, color: T.txt, marginBottom: "8px" }}>
        Timeline
      </h2>
      <p style={{ color: T.txt2, marginBottom: "28px", fontSize: "15px" }}>
        Document key moments in your guitar's history.
      </p>

      {data.events.length === 0 ? (
        <div style={{
          border: `2px dashed ${T.border}`, borderRadius: "12px", padding: "40px 24px",
          textAlign: "center", background: T.bgCard + "40"
        }}>
          <Calendar size={32} style={{ color: T.txtM, marginBottom: "12px" }} />
          <p style={{ color: T.txt2, marginBottom: "12px" }}>No events yet</p>
          <Button onClick={addEvent} variant="secondary">Add Your First Event</Button>
        </div>
      ) : (
        <div style={{ marginBottom: "20px" }}>
          {data.events.map((evt, idx) => (
            <div key={idx} style={{ marginBottom: "16px", padding: "16px", background: T.bgCard, borderRadius: "12px", border: `1px solid ${T.border}` }}>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "start", marginBottom: "12px" }}>
                <div style={{ flex: 1 }}>
                  <SelectInput
                    value={evt.type} onChange={e => updateEvent(idx, "type", e.target.value)}
                    options={["Purchase", "Repair", "Modification", "Customization", "Restoration", "Other"]}
                    placeholder="Select event type..."
                  />
                </div>
                <button
                  onClick={() => deleteEvent(idx)}
                  style={{
                    marginLeft: "12px", padding: "8px 12px", borderRadius: "8px",
                    background: "transparent", border: `1px solid ${T.border}`, color: "#F87171", cursor: "pointer"
                  }}
                >
                  <Trash2 size={14} />
                </button>
              </div>
              <FormField label="Date" hint="">
                <TextInput
                  value={evt.date} onChange={e => updateEvent(idx, "date", e.target.value)}
                  placeholder="YYYY-MM-DD" type="date"
                />
              </FormField>
              <FormField label="Description" hint="">
                <TextArea
                  value={evt.description} onChange={e => updateEvent(idx, "description", e.target.value)}
                  placeholder="What happened?" rows={3}
                />
              </FormField>
            </div>
          ))}
        </div>
      )}

      <Button onClick={addEvent} variant="secondary">
        <Calendar size={14} style={{ marginRight: "6px", display: "inline" }} />
        Add Event
      </Button>
    </div>
  );
}

function StepReview({ formData, aiAnalysis, serialResult }) {
  return (
    <div>
      <h2 style={{ fontFamily: "'Playfair Display', serif", fontSize: "28px", fontWeight: 600, color: T.txt, marginBottom: "8px" }}>
        Review Your Guitar
      </h2>
      <p style={{ color: T.txt2, marginBottom: "28px", fontSize: "15px" }}>
        Review all details before publishing to your collection.
      </p>

      {/* Preview Card */}
      <div style={{ background: T.bgCard, border: `1px solid ${T.border}`, borderRadius: "16px", overflow: "hidden", marginBottom: "24px" }}>
        <div style={{
          height: "240px", background: `linear-gradient(135deg, ${T.warm}, ${T.amber})`,
          display: "flex", alignItems: "center", justifyContent: "center"
        }}>
          {formData.photos.length > 0 ? (
            <img src={formData.photos[0].preview || formData.photos[0]} alt="Guitar" style={{ width: "100%", height: "100%", objectFit: "cover" }} />
          ) : (
            <Camera size={64} style={{ color: T.txt2 + "40" }} />
          )}
        </div>

        <div style={{ padding: "20px" }}>
          <h3 style={{ fontFamily: "'Playfair Display', serif", fontSize: "24px", fontWeight: 600, color: T.txt, marginBottom: "8px" }}>
            {formData.nickname || formData.model || "Your Guitar"}
          </h3>
          <p style={{ color: T.txt2, marginBottom: "16px", fontSize: "14px" }}>
            {formData.brand} {formData.model} {formData.year && `(${formData.year})`}
          </p>

          {formData.description && (
            <p style={{ fontSize: "13px", color: T.txtM, lineHeight: 1.6, marginBottom: "16px" }}>
              {formData.description.substring(0, 150)}...
            </p>
          )}

          <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "12px", fontSize: "12px" }}>
            {formData.bodyType && <div><span style={{ color: T.txtM }}>Body:</span> <span style={{ color: T.txt }}>{formData.bodyType}</span></div>}
            {formData.finish && <div><span style={{ color: T.txtM }}>Finish:</span> <span style={{ color: T.txt }}>{formData.finish}</span></div>}
            {formData.pickups && <div><span style={{ color: T.txtM }}>Pickups:</span> <span style={{ color: T.txt }}>{formData.pickups}</span></div>}
            {formData.serialNumber && <div><span style={{ color: T.txtM }}>S/N:</span> <span style={{ color: T.txt }}>{formData.serialNumber}</span></div>}
          </div>
        </div>
      </div>

      {/* Serial Verification Badge */}
      {serialResult && serialResult.success && (
        <div style={{ background: "#34D39915", border: "1px solid #34D39940", borderRadius: "12px", padding: "16px", marginBottom: "24px" }}>
          <div style={{ display: "flex", alignItems: "center", gap: "8px", marginBottom: "12px" }}>
            <Shield size={18} color="#34D399" />
            <span style={{ color: "#34D399", fontWeight: 600, fontSize: "14px" }}>Serial Number Verified</span>
          </div>
          <div style={{ fontSize: "13px", color: T.txt2, lineHeight: 1.6 }}>
            {serialResult.decoded?.year && <div><span style={{ color: T.txtM }}>Year:</span> <span style={{ color: T.txt, fontWeight: 500 }}>{serialResult.decoded.year}</span></div>}
            {serialResult.decoded?.yearRange && <div><span style={{ color: T.txtM }}>Year Range:</span> <span style={{ color: T.txt, fontWeight: 500 }}>{serialResult.decoded.yearRange}</span></div>}
            {serialResult.decoded?.factory && <div><span style={{ color: T.txtM }}>Factory:</span> <span style={{ color: T.txt, fontWeight: 500 }}>{serialResult.decoded.factory}</span></div>}
            {serialResult.decoded?.country && <div><span style={{ color: T.txtM }}>Country:</span> <span style={{ color: T.txt, fontWeight: 500 }}>{serialResult.decoded.country}</span></div>}
          </div>
        </div>
      )}

      {/* AI Analysis Card */}
      {aiAnalysis && (
        <div style={{ background: T.bgCard, border: `1px solid ${T.borderAcc}`, borderRadius: "12px", padding: "16px", marginBottom: "24px" }}>
          <h4 style={{ fontSize: "14px", fontWeight: 600, color: T.txt, marginBottom: "12px", display: "flex", alignItems: "center", gap: "8px" }}>
            <Sparkles size={16} color={T.warm} />
            Analysis Summary
          </h4>
          <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "16px", fontSize: "13px" }}>
            <div>
              <span style={{ color: T.txtM }}>Brand</span>
              <div style={{ display: "flex", alignItems: "center", gap: "8px", marginTop: "4px" }}>
                <span style={{ color: T.txt, fontWeight: 500 }}>{aiAnalysis.brand.value}</span>
                <ConfidenceMeter value={aiAnalysis.brand.confidence} />
              </div>
            </div>
            <div>
              <span style={{ color: T.txtM }}>Model</span>
              <div style={{ display: "flex", alignItems: "center", gap: "8px", marginTop: "4px" }}>
                <span style={{ color: T.txt, fontWeight: 500 }}>{aiAnalysis.model.value}</span>
                <ConfidenceMeter value={aiAnalysis.model.confidence} />
              </div>
            </div>
            <div>
              <span style={{ color: T.txtM }}>Year</span>
              <div style={{ display: "flex", alignItems: "center", gap: "8px", marginTop: "4px" }}>
                <span style={{ color: T.txt, fontWeight: 500 }}>{aiAnalysis.year.value}</span>
                <ConfidenceMeter value={aiAnalysis.year.confidence} />
              </div>
            </div>
            <div>
              <span style={{ color: T.txtM }}>Body Style</span>
              <div style={{ display: "flex", alignItems: "center", gap: "8px", marginTop: "4px" }}>
                <span style={{ color: T.txt, fontWeight: 500 }}>{aiAnalysis.bodyStyle.value}</span>
                <ConfidenceMeter value={aiAnalysis.bodyStyle.confidence} />
              </div>
            </div>
            {aiAnalysis.estimatedValue && (
              <div>
                <span style={{ color: T.txtM }}>Est. Value</span>
                <div style={{ marginTop: "4px" }}>
                  <span style={{ color: T.txt, fontWeight: 500 }}>{aiAnalysis.estimatedValue}</span>
                </div>
              </div>
            )}
            {aiAnalysis.rarity && (
              <div>
                <span style={{ color: T.txtM }}>Rarity</span>
                <div style={{ marginTop: "4px" }}>
                  <Badge variant={aiAnalysis.rarity === 'Rare' ? 'warm' : 'default'}>
                    {aiAnalysis.rarity}
                  </Badge>
                </div>
              </div>
            )}
          </div>
        </div>
      )}

      {/* Timeline Events */}
      {formData.events && formData.events.length > 0 && (
        <div style={{ background: T.bgCard, border: `1px solid ${T.border}`, borderRadius: "12px", padding: "16px", marginBottom: "24px" }}>
          <h4 style={{ fontSize: "14px", fontWeight: 600, color: T.txt, marginBottom: "12px" }}>
            Timeline ({formData.events.length} event{formData.events.length !== 1 ? "s" : ""})
          </h4>
          {formData.events.map((evt, idx) => (
            <div key={idx} style={{ fontSize: "13px", color: T.txtM, marginBottom: idx < formData.events.length - 1 ? "8px" : 0, paddingLeft: "12px", borderLeft: `2px solid ${T.warm}` }}>
              <span style={{ color: T.txt, fontWeight: 500 }}>{evt.type || "Event"}</span>
              {evt.date && <span> â€” {evt.date}</span>}
              {evt.description && <p style={{ margin: "2px 0 0", fontSize: "12px" }}>{evt.description}</p>}
            </div>
          ))}
        </div>
      )}

      <div style={{ background: T.bgCard, border: `1px solid ${T.border}`, borderRadius: "12px", padding: "16px", marginBottom: "24px" }}>
        <p style={{ fontSize: "13px", color: T.txtM, lineHeight: 1.6 }}>
          âœ“ All essential information complete<br />
          âœ“ Ready to publish to your collection<br />
          âœ“ You can edit anytime from your library
        </p>
      </div>
    </div>
  );
}

function AddGuitarManual({ initialData }) {
  const navigate = useNavigate();
  const { user } = useAuth();
  // If pre-filled from Magic Add (has photos + some fields), start at step 2
  const hasInitialPhotos = initialData && initialData.photos && initialData.photos.length > 0;
  const hasInitialFields = initialData && (initialData.brand || initialData.model);
  const [currentStep, setCurrentStep] = useState(hasInitialPhotos && hasInitialFields ? 2 : 1);
  const [submitting, setSubmitting] = useState(false);
  const [submitError, setSubmitError] = useState(null);
  const [aiAnalysis, setAiAnalysis] = useState(null);
  const [serialResult, setSerialResult] = useState(null);
  const [formData, setFormData] = useState(initialData || {
    photos: [],
    brand: "", model: "", year: "", serialNumber: "", country: "",
    bodyType: "", bodyWood: "", topWood: "", finish: "", color: "",
    neckWood: "", fretboardWood: "", neckProfile: "", scaleLength: "", frets: "",
    pickupConfig: "", pickups: "", controls: "", wiringMods: "",
    bridgeType: "", bridgeModel: "", tuners: "", nutMaterial: "", hardwareFinish: "",
    nickname: "", description: "", events: []
  });

  // Auto-generate AI analysis when brand + model are filled
  const generateAnalysis = useCallback(() => {
    if (!formData.brand || !formData.model) {
      setAiAnalysis(null);
      return;
    }
    const analysis = {
      brand: { value: formData.brand, confidence: 0.95 },
      model: { value: formData.model, confidence: 0.90 },
      year: { value: formData.year || 'Unknown', confidence: formData.year ? 0.85 : 0.30 },
      bodyStyle: { value: formData.bodyType || 'Solid Body', confidence: 0.70 },
      estimatedValue: formData.year && parseInt(formData.year) < 1970 ? '$2,500 - $8,000' : '$500 - $2,500',
      rarity: formData.year && parseInt(formData.year) < 1960 ? 'Rare' : 'Common',
      serialVerified: serialResult?.success ? true : false,
    };
    setAiAnalysis(analysis);
  }, [formData, serialResult]);

  useEffect(() => {
    generateAnalysis();
  }, [formData.brand, formData.model, formData.year, formData.bodyType, serialResult, generateAnalysis]);

  const isStepValid = () => {
    if (currentStep === 1) return formData.photos.length > 0;
    if (currentStep === 2) return formData.brand && formData.model;
    return true;
  };

  // Map body type display labels to DB values
  const BODY_STYLE_MAP = {
    "Solid Body": "solid", "Semi-Hollow": "semi-hollow", "Hollow Body": "hollow",
    "Acoustic": "acoustic", "Classical": "classical", "Bass": "bass",
    "12-String": "12-string", "Other": "other",
  };

  const handleSubmit = async (state = 'published') => {
    if (!user) return;
    setSubmitting(true);
    setSubmitError(null);

    try {
      // 1. Build specifications JSONB from form fields
      const specifications = {};
      if (formData.bodyWood) specifications.body_material = formData.bodyWood;
      if (formData.topWood) specifications.top_material = formData.topWood;
      if (formData.color) specifications.color = formData.color;
      if (formData.neckWood) specifications.neck_material = formData.neckWood;
      if (formData.fretboardWood) specifications.fretboard = formData.fretboardWood;
      if (formData.neckProfile) specifications.neck_profile = formData.neckProfile;
      if (formData.scaleLength) specifications.scale_length = formData.scaleLength;
      if (formData.frets) specifications.num_frets = parseInt(formData.frets);
      if (formData.pickupConfig) specifications.pickup_config = formData.pickupConfig;
      if (formData.pickups) specifications.pickups = formData.pickups;
      if (formData.controls) specifications.controls = formData.controls;
      if (formData.wiringMods) specifications.wiring_mods = formData.wiringMods;
      if (formData.bridgeType) specifications.bridge_type = formData.bridgeType;
      if (formData.bridgeModel) specifications.bridge = formData.bridgeModel;
      if (formData.tuners) specifications.tuners = formData.tuners;
      if (formData.nutMaterial) specifications.nut_material = formData.nutMaterial;
      if (formData.hardwareFinish) specifications.hardware_finish = formData.hardwareFinish;
      if (formData.country) specifications.country_of_origin = formData.country;

      // 2. Create guitar record in DB
      const guitar = await createGuitar({
        owner_id: user.id,
        brand: formData.brand,
        model: formData.model,
        year: formData.year ? parseInt(formData.year) : null,
        serial_number: formData.serialNumber || null,
        body_style: BODY_STYLE_MAP[formData.bodyType] || (formData.bodyType ? formData.bodyType.toLowerCase() : null),
        instrument_type: 'electric',
        finish: formData.finish || null,
        specifications,
        state,
        source: initialData ? 'magic_add' : 'manual',
      });
      const guitarId = guitar.id;

      // 3. Upload photos to Supabase Storage & create OCC records
      for (let i = 0; i < formData.photos.length; i++) {
        const photo = formData.photos[i];
        if (!photo.file) continue;

        const fileExt = photo.file.name.split('.').pop().toLowerCase();
        const storagePath = `${user.id}/${guitarId}/${i}.${fileExt}`;

        const { error: uploadError } = await supabase.storage
          .from('guitar-images')
          .upload(storagePath, photo.file, { cacheControl: '3600', upsert: false });

        if (uploadError) {
          console.error(`Photo ${i} upload error:`, uploadError);
          // Continue with other photos â€” don't block the whole submission
          continue;
        }

        const { data: { publicUrl } } = supabase.storage
          .from('guitar-images')
          .getPublicUrl(storagePath);

        await supabase.from('owner_created_content').insert({
          ie_id: guitarId,
          creator_id: user.id,
          content_type: 'image',
          content_data: {
            url: publicUrl,
            thumbnail_url: publicUrl,
            full_url: publicUrl,
            alt_text: `${formData.brand} ${formData.model} - Photo ${i + 1}`,
          },
          visible_publicly: true,
          visible_to_future_owners: false,
          position: i,
        });
      }

      // 4. Create OCC record for nickname (if provided)
      if (formData.nickname) {
        await supabase.from('owner_created_content').insert({
          ie_id: guitarId, creator_id: user.id,
          content_type: 'nickname',
          content_data: { name: formData.nickname },
          visible_publicly: true, visible_to_future_owners: false, position: 0,
        });
      }

      // 5. Create OCC record for story/description (if provided)
      if (formData.description) {
        await supabase.from('owner_created_content').insert({
          ie_id: guitarId, creator_id: user.id,
          content_type: 'story',
          content_data: { text: formData.description },
          visible_publicly: true, visible_to_future_owners: false, position: 0,
        });
      }

      // 6. Create OCC records for timeline events (if provided)
      if (formData.events && formData.events.length > 0) {
        for (let i = 0; i < formData.events.length; i++) {
          const evt = formData.events[i];
          if (evt.type || evt.date || evt.description) {
            await supabase.from('owner_created_content').insert({
              ie_id: guitarId, creator_id: user.id,
              content_type: 'timeline_event',
              content_data: {
                event_type: evt.type,
                date: evt.date,
                description: evt.description,
                order: i,
              },
              visible_publicly: true, visible_to_future_owners: false, position: i,
            });
          }
        }
      }

      // 7. Navigate to the new guitar's detail page
      navigate(`/guitar/${guitarId}`);
    } catch (err) {
      console.error('Submit error:', err);
      setSubmitError(err.message || 'Something went wrong. Please try again.');
    } finally {
      setSubmitting(false);
    }
  };

  const renderStep = () => {
    switch (currentStep) {
      case 1: return <StepPhotos photos={formData.photos} setPhotos={p => setFormData(prev => ({ ...prev, photos: p }))} />;
      case 2: return <StepBasicInfo data={formData} setData={setFormData} onSerialResult={setSerialResult} onAutoFill={(catalogEntry) => console.log('[TWNG] Auto-filled from catalog:', catalogEntry?.brand, catalogEntry?.model)} />;
      case 3: return <StepSpecs data={formData} setData={setFormData} />;
      case 4: return <StepStory data={formData} setData={setFormData} />;
      case 5: return <StepTimeline data={formData} setData={setFormData} />;
      case 6: return <StepReview formData={formData} aiAnalysis={aiAnalysis} serialResult={serialResult} />;
      default: return null;
    }
  };

  return (
    <div style={{ flex: 1 }}>
      <style>{`
        @media (max-width: 768px) {
          .add-guitar-container { padding: 24px 16px !important; }
          .progress-bar { flex-wrap: wrap; gap: 4px !important; }
          .progress-step { flex: 0 1 auto !important; }
          .progress-connector { display: none; }
          .form-actions { flex-direction: column !important; gap: 8px !important; }
        }
        @media (max-width: 480px) {
          .add-guitar-container { padding: 16px 12px !important; }
          .progress-bar-number { width: 24px !important; height: 24px !important; font-size: 10px !important; }
          .form-step-title { font-size: 18px !important; }
          .upload-zone { min-height: 120px !important; }
        }
      `}</style>
      <div style={{ maxWidth: "680px", margin: "0 auto", padding: "40px 24px" }} className="add-guitar-container">
        <ProgressBar currentStep={currentStep} />
        <div style={{ marginTop: "40px" }}>
          {renderStep()}
        </div>

        {/* Error banner */}
        {submitError && (
          <div style={{
            marginTop: "16px", padding: "12px 16px", borderRadius: "10px",
            background: "#7F1D1D20", border: "1px solid #7F1D1D40",
            color: "#F87171", fontSize: "13px", display: "flex", alignItems: "center", gap: "8px"
          }}>
            <AlertTriangle size={14} />
            {submitError}
          </div>
        )}

        {/* Navigation */}
        <div style={{
          display: "flex", gap: "12px", marginTop: "48px", justifyContent: "space-between",
          borderTop: `1px solid ${T.border}`, paddingTop: "24px"
        }} className="form-actions">
          <div style={{ display: "flex", gap: "12px" }} className="mobile-stack">
            <Button
              variant="ghost"
              onClick={() => setCurrentStep(Math.max(1, currentStep - 1))}
              disabled={currentStep === 1 || submitting}
            >
              <ArrowLeft size={14} style={{ marginRight: "6px", display: "inline" }} />
              Previous
            </Button>
            <Button
              variant="secondary"
              onClick={() => handleSubmit('draft')}
              disabled={submitting || !formData.brand || !formData.model}
            >
              {submitting ? 'Saving...' : 'Save Draft'}
            </Button>
          </div>

          {currentStep === 6 ? (
            <Button
              onClick={() => handleSubmit('published')}
              disabled={submitting || formData.photos.length === 0}
            >
              {submitting && <Loader size={14} style={{ marginRight: "6px", display: "inline", animation: "spin 1s linear infinite" }} />}
              {submitting ? 'Publishing...' : 'Publish'}
            </Button>
          ) : (
            <Button
              onClick={() => setCurrentStep(Math.min(6, currentStep + 1))}
              disabled={!isStepValid() || submitting}
            >
              Next
              <ArrowRight size={14} style={{ marginLeft: "6px", display: "inline" }} />
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}

// ============================================================
// PAGE 2: MAGIC ADD (AI-POWERED)
// ============================================================
function ProcessingAnimation({ progress, stage }) {
  const stages = [
    { label: "Analyzing image...", detail: "Detecting guitar features" },
    { label: "Identifying brand...", detail: "Matching headstock and body" },
    { label: "Matching model...", detail: "Comparing database records" },
    { label: "Extracting specs...", detail: "Reading hardware and details" },
    { label: "Finalizing...", detail: "Cross-referencing data" },
  ];
  const current = stages[stage] || stages[0];

  return (
    <div style={{ textAlign: "center", padding: "60px 24px" }}>
      <div style={{ position: "relative", width: "120px", height: "120px", margin: "0 auto 32px" }}>
        <div style={{
          width: "120px", height: "120px", borderRadius: "50%",
          background: `conic-gradient(${T.warm} ${progress}%, transparent ${progress}%)`,
          display: "flex", alignItems: "center", justifyContent: "center",
          animation: "spin 3s linear infinite",
        }}>
          <div style={{
            width: "104px", height: "104px", borderRadius: "50%", background: T.bgDeep,
            display: "flex", alignItems: "center", justifyContent: "center"
          }}>
            <Sparkles size={36} style={{ color: T.warm }} />
          </div>
        </div>
      </div>

      <h2 style={{ fontFamily: "'Playfair Display', serif", fontSize: "24px", fontWeight: 600, color: T.txt, marginBottom: "8px" }}>
        {current.label}
      </h2>
      <p style={{ fontSize: "14px", color: T.txt2, marginBottom: "32px" }}>{current.detail}</p>

      <div style={{ maxWidth: "400px", margin: "0 auto" }}>
        <div style={{ height: "4px", borderRadius: "2px", background: T.border, overflow: "hidden" }}>
          <div style={{
            height: "100%", width: `${progress}%`,
            background: `linear-gradient(90deg, ${T.warm}, ${T.amber})`,
            borderRadius: "2px", transition: "width 0.3s ease"
          }} />
        </div>
        <p style={{ fontSize: "12px", color: T.txtM, fontFamily: "'JetBrains Mono', monospace", marginTop: "8px" }}>
          {progress}% complete
        </p>
      </div>

      <style>{`@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }`}</style>
    </div>
  );
}

// Boutique brands commonly confused with major brands
const BOUTIQUE_ALTERNATIVES = {
  Fender: ["Nash", "Suhr", "Tom Anderson", "K-Line", "LSL", "Haar", "Danocaster", "Fano", "Novo", "Don Grosh", "Melancon"],
  Gibson: ["Heritage", "Collings", "Eastman", "Knaggs", "Nik Huber", "Epiphone"],
  Heritage: ["Gibson", "Collings", "Eastman", "Knaggs", "Nik Huber"],
  Epiphone: ["Gibson", "Heritage", "Eastman", "Tokai", "Greco"],
  Squier: ["Fender", "Nash", "Suhr", "Tom Anderson", "K-Line"],
  "PRS": ["Knaggs"],
};

function BrandCorrectionBanner({ currentBrand, onCorrect }) {
  const [expanded, setExpanded] = useState(false);
  const [customBrand, setCustomBrand] = useState("");
  const alternatives = BOUTIQUE_ALTERNATIVES[currentBrand] || [];

  const handleApply = () => {
    if (customBrand.trim()) {
      onCorrect(customBrand.trim());
      setCustomBrand("");
      setExpanded(false);
    }
  };

  return (
    <div style={{
      background: T.bgDeep, border: `1px solid ${T.borderAcc}40`, borderRadius: "12px",
      padding: "14px 16px", marginBottom: "16px",
    }}>
      <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
        <p style={{ fontSize: "13px", color: T.txt2 }}>
          <AlertTriangle size={14} style={{ display: "inline", marginRight: "6px", verticalAlign: "text-bottom", color: T.amber }} />
          Wrong brand? AI can mistake boutique builders for {currentBrand || "major brands"}.
        </p>
        <button
          onClick={() => setExpanded(!expanded)}
          style={{
            padding: "6px 14px", borderRadius: "8px", fontSize: "12px", fontWeight: 600,
            background: T.warm + "20", border: `1px solid ${T.warm}40`, color: T.warm,
            cursor: "pointer", whiteSpace: "nowrap", marginLeft: "12px",
          }}
        >
          {expanded ? "Hide" : "Correct Brand"}
        </button>
      </div>
      {expanded && (
        <div style={{ marginTop: "12px" }}>
          {alternatives.length > 0 && (
            <div style={{ marginBottom: "12px" }}>
              <p style={{ fontSize: "11px", color: T.txtM, marginBottom: "8px", fontFamily: "'JetBrains Mono', monospace" }}>
                Common alternatives:
              </p>
              <div style={{ display: "flex", gap: "6px", flexWrap: "wrap" }}>
                {alternatives.map(brand => (
                  <button
                    key={brand}
                    onClick={() => { onCorrect(brand); setExpanded(false); }}
                    style={{
                      padding: "6px 12px", borderRadius: "6px", fontSize: "12px", fontWeight: 500,
                      background: T.bgCard, border: `1px solid ${T.border}`, color: T.txt,
                      cursor: "pointer", transition: "all 0.15s",
                    }}
                    onMouseEnter={e => { e.currentTarget.style.borderColor = T.warm; e.currentTarget.style.color = T.warm; }}
                    onMouseLeave={e => { e.currentTarget.style.borderColor = T.border; e.currentTarget.style.color = T.txt; }}
                  >
                    {brand}
                  </button>
                ))}
              </div>
            </div>
          )}
          <div style={{ display: "flex", gap: "8px", alignItems: "center" }}>
            <input
              value={customBrand}
              onChange={e => setCustomBrand(e.target.value)}
              placeholder="Or type the correct brand..."
              style={{
                flex: 1, padding: "8px 12px", borderRadius: "8px", fontSize: "13px",
                background: T.bgCard, border: `1px solid ${T.border}`, color: T.txt, outline: "none",
              }}
              onFocus={e => e.currentTarget.style.borderColor = T.warm}
              onBlur={e => e.currentTarget.style.borderColor = T.border}
              onKeyDown={e => { if (e.key === "Enter") handleApply(); }}
            />
            <button
              onClick={handleApply}
              disabled={!customBrand.trim()}
              style={{
                padding: "8px 16px", borderRadius: "8px", fontSize: "12px", fontWeight: 600,
                background: customBrand.trim() ? T.warm : T.bgCard,
                color: customBrand.trim() ? T.bgDeep : T.txtM,
                border: `1px solid ${customBrand.trim() ? T.warm : T.border}`,
                cursor: customBrand.trim() ? "pointer" : "default",
                whiteSpace: "nowrap",
              }}
            >
              Apply
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

function AIResultField({ label, result, onEdit }) {
  const [editing, setEditing] = useState(false);
  const [value, setValue] = useState(result.value);
  const [showAlternatives, setShowAlternatives] = useState(false);

  return (
    <div style={{
      display: "flex", justifyContent: "space-between", alignItems: "center",
      padding: "14px 0", borderBottom: `1px solid ${T.border}20`
    }}>
      <div style={{ flex: 1 }}>
        <p style={{ fontSize: "12px", color: T.txtM, marginBottom: "4px" }}>{label}</p>
        {editing ? (
          <div style={{ display: "flex", gap: "8px", alignItems: "center" }}>
            <input
              value={value} onChange={e => setValue(e.target.value)}
              style={{
                padding: "6px 10px", borderRadius: "6px", background: T.bgCard,
                border: `1px solid ${T.borderAcc}`, color: T.txt, fontSize: "14px",
                outline: "none", flex: 1
              }}
              autoFocus
            />
            <button
              onClick={() => { setEditing(false); onEdit && onEdit(value); }}
              style={{
                padding: "6px", borderRadius: "6px", background: T.warm,
                border: "none", color: T.bgDeep, cursor: "pointer"
              }}
            >
              <Check size={14} />
            </button>
            <button
              onClick={() => { setValue(result.value); setEditing(false); }}
              style={{
                padding: "6px", borderRadius: "6px", background: "transparent",
                border: `1px solid ${T.border}`, color: T.txtM, cursor: "pointer"
              }}
            >
              <X size={14} />
            </button>
          </div>
        ) : (
          <p style={{ fontSize: "15px", color: T.txt, fontWeight: 500 }}>{value}</p>
        )}
      </div>
      <div style={{ display: "flex", alignItems: "center", gap: "12px", marginLeft: "16px" }}>
        <ConfidenceMeter value={result.confidence} />
        {!editing && (
          <button
            onClick={() => setEditing(true)}
            style={{
              padding: "6px", borderRadius: "6px", background: "transparent",
              border: `1px solid ${T.border}`, color: T.txtM, cursor: "pointer"
            }}
          >
            <Edit3 size={13} />
          </button>
        )}
      </div>
    </div>
  );
}

function MagicAddAI({ onComplete, onSwitchManual }) {
  const fileInputRef = useRef(null);
  const [phase, setPhase] = useState("upload"); // upload | processing | results | failed
  const [uploadedPhotos, setUploadedPhotos] = useState([]); // { file, preview }[]
  const [dragActive, setDragActive] = useState(false);
  const [progress, setProgress] = useState(0);
  const [stage, setStage] = useState(0);
  const [results, setResults] = useState(EMPTY_RESULT);
  const [isDemo, setIsDemo] = useState(false); // true only when showing hardcoded Heritage demo (should not happen in prod)
  const [analysisSource, setAnalysisSource] = useState(""); // "real" | "smart-fallback" | "empty"
  const [aiNotes, setAiNotes] = useState(""); // notes from real AI analysis
  const [failReason, setFailReason] = useState(""); // error message for failed phase

  const handleFiles = (files) => {
    const validFiles = Array.from(files).filter(f => {
      if (!f.type.match(/^image\/(jpeg|png|webp|gif)$/)) return false;
      if (f.size > 10 * 1024 * 1024) return false;
      return true;
    });
    if (validFiles.length === 0) return;
    const newPhotos = validFiles.map(file => ({ file, preview: URL.createObjectURL(file) }));
    setUploadedPhotos(prev => [...prev, ...newPhotos].slice(0, 5));
  };

  const removePhoto = (idx) => {
    setUploadedPhotos(prev => prev.filter((_, i) => i !== idx));
  };

  const { user } = useAuth();
  const analysisRef = useRef(null); // tracks if AI call is in-flight

  // Compress image to max dimensions and JPEG quality for base64 transfer
  const compressImage = (file, maxSize = 1024, quality = 0.7) => {
    return new Promise((resolve, reject) => {
      const img = new window.Image();
      img.onload = () => {
        let { width, height } = img;
        if (width > maxSize || height > maxSize) {
          const ratio = Math.min(maxSize / width, maxSize / height);
          width = Math.round(width * ratio);
          height = Math.round(height * ratio);
        }
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        const dataUrl = canvas.toDataURL('image/jpeg', quality);
        resolve(dataUrl);
      };
      img.onerror = () => reject(new Error('Failed to load image'));
      img.src = URL.createObjectURL(file);
    });
  };

  // Invoke Edge Function with timeout and retry logic
  const invokeAnalyzeFunction = async (requestBody, retryCount = 0) => {
    const maxRetries = 1;
    const timeoutPromise = new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Edge Function timeout')), AI_TIMEOUT_MS)
    );

    try {
      const invocationPromise = supabase.functions.invoke(ANALYZE_FUNCTION, { body: requestBody });
      const { data, error } = await Promise.race([invocationPromise, timeoutPromise]);

      if (error) {
        if (retryCount < maxRetries) {
          console.warn('[MagicAdd] Edge Function error, retrying...', error);
          await new Promise(resolve => setTimeout(resolve, 500)); // 500ms delay before retry
          return invokeAnalyzeFunction(requestBody, retryCount + 1);
        }
        throw error;
      }

      return { data, error: null };
    } catch (err) {
      if (retryCount < maxRetries) {
        console.warn('[MagicAdd] Edge Function call failed, retrying...', err?.message);
        await new Promise(resolve => setTimeout(resolve, 500));
        return invokeAnalyzeFunction(requestBody, retryCount + 1);
      }
      return { data: null, error: err };
    }
  };

  const handleAnalyze = async () => {
    if (uploadedPhotos.length === 0) return;
    setPhase("processing");
    setProgress(0);
    setStage(0);
    setIsDemo(false);
    setAnalysisSource("");
    setAiNotes("");
    setFailReason("");

    try {
      // 1. Try uploading photos to Storage, with compressed base64 fallback
      const photoUrls = [];
      const photoBase64 = [];
      const tempPrefix = `${user?.id || 'anon'}/magic-add-${Date.now()}`;

      for (let i = 0; i < uploadedPhotos.length; i++) {
        const photo = uploadedPhotos[i];
        const ext = photo.file.name.split('.').pop().toLowerCase();
        const path = `${tempPrefix}/${i}.${ext}`;

        // Only try storage if user is logged in
        let uploaded = false;
        if (user?.id) {
          const { error: upErr } = await supabase.storage
            .from('guitar-images')
            .upload(path, photo.file, { cacheControl: '3600', upsert: false });
          if (!upErr) {
            const { data: { publicUrl } } = supabase.storage
              .from('guitar-images')
              .getPublicUrl(path);
            photoUrls.push(publicUrl);
            uploaded = true;
          } else {
            console.warn('[MagicAdd] Storage upload failed for photo', i, ':', upErr.message);
          }
        }

        // Fallback: compress and convert to base64
        if (!uploaded) {
          try {
            const compressed = await compressImage(photo.file, 1024, 0.75);
            photoBase64.push(compressed);
          } catch (compErr) {
            console.warn('[MagicAdd] Failed to compress photo', i, ':', compErr.message);
          }
        }
      }

      // 2. Try to call the analyze-guitar Edge Function
      analysisRef.current = true;

      if (photoUrls.length === 0 && photoBase64.length === 0) {
        console.error('[MagicAdd] No photos processed successfully');
        setFailReason("Could not process photos. Please try again.");
        setProgress(100);
        setPhase("failed");
        return;
      }

      const requestBody = photoUrls.length > 0
        ? { photoUrls }
        : { photoBase64 };

      const { data, error } = await invokeAnalyzeFunction(requestBody);

      if (!analysisRef.current) return; // component unmounted or reset

      if (error) {
        console.error('[MagicAdd] Edge Function error:', error?.message || error);
        throw error;
      }

      // Handle case where data might be a string (not auto-parsed)
      let parsedData = data;
      if (typeof data === 'string') {
        try { parsedData = JSON.parse(data); } catch { parsedData = data; }
      }

      if (parsedData?.error) {
        console.error('[MagicAdd] AI returned error:', parsedData.error);
        throw new Error(parsedData.error);
      }

      // 3. Got real AI results â€” validate shape and use them
      if (parsedData?.brand?.value && parsedData?.model?.value) {
        setResults(parsedData);
        setAnalysisSource("real");
        setIsDemo(false);
        if (parsedData.notes) setAiNotes(parsedData.notes);
      } else {
        console.warn('[MagicAdd] AI returned unexpected format:', parsedData);
        throw new Error('AI returned unexpected response format');
      }
      setProgress(100);
      setStage(4);
      setTimeout(() => setPhase("results"), 300);

    } catch (err) {
      console.error('[MagicAdd] Analysis failed:', err?.message || err);
      analysisRef.current = false;

      // Fallback: Use smart client-side analysis from filenames
      const smartResults = analyzeGuitarFromPhotos(uploadedPhotos);
      if (smartResults.brand.value || smartResults.model.value) {
        setResults(smartResults);
        setAnalysisSource("smart-fallback");
        setIsDemo(false);
      } else {
        setResults(EMPTY_RESULT);
        setAnalysisSource("empty");
        setIsDemo(false);
      }

      // Let the progress animation finish naturally, then show results
      setProgress(100);
      setStage(4);
      setTimeout(() => setPhase("results"), 300);
    }
  };

  // Progress animation â€” runs during processing phase
  // If real AI returns first, it jumps to 100%. Otherwise, simulated.
  useEffect(() => {
    if (phase !== "processing") return;
    const interval = setInterval(() => {
      setProgress(p => {
        if (p >= 100) {
          clearInterval(interval);
          // Only set results phase if the AI call didn't already handle it
          if (!analysisRef.current) {
            setPhase("results");
          }
          return 100;
        }
        // Slow down near the end if waiting for real AI
        const increment = analysisRef.current && p > 70 ? 0.5 : 2;
        const newP = Math.min(p + increment, analysisRef.current ? 85 : 100);
        setStage(Math.floor(newP / 20));
        return newP;
      });
    }, 80);
    return () => clearInterval(interval);
  }, [phase]);

  // Map AI results into manual form data shape and hand off
  const handleContinueToForm = () => {
    const yearStr = results.year.value;
    // Handle year ranges like "2020-2024" â€” take the first year
    const yearMatch = yearStr.match(/\d{4}/);
    const year = yearMatch ? yearMatch[0] : "";

    const prefill = {
      photos: uploadedPhotos,
      brand: results.brand?.value || "",
      model: results.model?.value || "",
      year,
      serialNumber: "",
      country: results.country?.value || "",
      bodyType: results.bodyType?.value || "",
      bodyWood: results.bodyWood?.value || "",
      topWood: results.topWood?.value || "",
      finish: results.finish?.value || "",
      color: results.color?.value || "",
      neckWood: results.neckWood?.value || "",
      fretboardWood: results.fretboardWood?.value || "",
      neckProfile: results.neckProfile?.value || "",
      scaleLength: results.scaleLength?.value || "",
      frets: results.frets?.value || "",
      pickupConfig: results.pickupConfig?.value || "",
      pickups: results.pickups?.value || "",
      controls: results.controls?.value || "",
      wiringMods: "",
      bridgeType: results.bridgeType?.value || "",
      bridgeModel: results.bridge?.value || "",
      tuners: results.tuners?.value || "",
      nutMaterial: results.nutMaterial?.value || "",
      hardwareFinish: results.hardwareFinish?.value || "",
      nickname: "", description: "", events: [],
    };
    onComplete(prefill);
  };

  const handleEnterManually = () => {
    // Pass photos but no pre-filled fields
    if (uploadedPhotos.length > 0) {
      onComplete({
        photos: uploadedPhotos,
        brand: "", model: "", year: "", serialNumber: "", country: "",
        bodyType: "", bodyWood: "", topWood: "", finish: "", color: "",
        neckWood: "", fretboardWood: "", neckProfile: "", scaleLength: "", frets: "",
        pickupConfig: "", pickups: "", controls: "", wiringMods: "",
        bridgeType: "", bridgeModel: "", tuners: "", nutMaterial: "", hardwareFinish: "",
        nickname: "", description: "", events: [],
      });
    } else {
      onSwitchManual();
    }
  };

  const resetAll = () => {
    setPhase("upload");
    setUploadedPhotos([]);
    setProgress(0);
    setStage(0);
    setResults(EMPTY_RESULT);
    setIsDemo(false);
    setAnalysisSource("");
    setAiNotes("");
    setFailReason("");
    analysisRef.current = null;
  };

  // --- UPLOAD PHASE ---
  const renderUpload = () => (
    <div>
      <h2 style={{ fontFamily: "'Playfair Display', serif", fontSize: "28px", fontWeight: 600, color: T.txt, marginBottom: "8px" }}>
        Magic Add (AI-Powered)
      </h2>
      <p style={{ color: T.txt2, marginBottom: "28px", fontSize: "15px" }}>
        Upload photos of your guitar and we'll identify it automatically.
      </p>

      <input
        ref={fileInputRef}
        type="file"
        accept="image/jpeg,image/png,image/webp,image/gif"
        multiple
        style={{ display: 'none' }}
        onChange={(e) => {
          if (e.target.files && e.target.files.length > 0) handleFiles(e.target.files);
          e.target.value = '';
        }}
      />

      <div
        onClick={() => fileInputRef.current?.click()}
        onDragOver={(e) => { e.preventDefault(); e.stopPropagation(); setDragActive(true); }}
        onDragEnter={(e) => { e.preventDefault(); e.stopPropagation(); setDragActive(true); }}
        onDragLeave={(e) => { e.preventDefault(); e.stopPropagation(); setDragActive(false); }}
        onDrop={(e) => {
          e.preventDefault(); e.stopPropagation(); setDragActive(false);
          if (e.dataTransfer.files) handleFiles(e.dataTransfer.files);
        }}
        style={{
          border: `2px dashed ${dragActive ? T.warm : T.border}`, borderRadius: "16px",
          padding: uploadedPhotos.length > 0 ? "24px" : "56px 24px",
          textAlign: "center", cursor: "pointer",
          background: dragActive ? T.warm + "08" : T.bgCard,
          transition: "all 0.2s", marginBottom: "24px"
        }}
        onMouseEnter={e => { if (!dragActive) { e.currentTarget.style.borderColor = T.warm; e.currentTarget.style.background = T.warm + "08"; }}}
        onMouseLeave={e => { if (!dragActive) { e.currentTarget.style.borderColor = T.border; e.currentTarget.style.background = T.bgCard; }}}
      >
        {uploadedPhotos.length === 0 ? (
          <>
            <Upload size={48} style={{ color: T.txtM, marginBottom: "16px" }} />
            <p style={{ color: T.txt, fontWeight: 600, marginBottom: "6px", fontSize: "15px" }}>
              {dragActive ? "Drop photos here" : "Upload 1-5 photos of your guitar"}
            </p>
            <p style={{ fontSize: "13px", color: T.txtM }}>JPG, PNG, WebP Â· Max 10MB per image</p>
          </>
        ) : (
          <>
            <div style={{ display: "flex", gap: "12px", justifyContent: "center", flexWrap: "wrap", marginBottom: "12px" }}>
              {uploadedPhotos.map((p, i) => (
                <div key={i} style={{ position: "relative", width: "80px", height: "80px", borderRadius: "10px", overflow: "hidden", border: `2px solid ${i === 0 ? T.warm : T.border}` }}>
                  <img src={p.preview} alt={`Upload ${i + 1}`} style={{ width: "100%", height: "100%", objectFit: "cover" }} />
                  <button
                    onClick={e => { e.stopPropagation(); removePhoto(i); }}
                    style={{
                      position: "absolute", top: "4px", right: "4px", width: "18px", height: "18px",
                      borderRadius: "50%", background: T.bgDeep + "CC", border: "none",
                      color: T.txt, display: "flex", alignItems: "center", justifyContent: "center", cursor: "pointer", padding: 0
                    }}
                  >
                    <X size={10} />
                  </button>
                </div>
              ))}
              {uploadedPhotos.length < 5 && (
                <div style={{
                  width: "80px", height: "80px", borderRadius: "10px", border: `2px dashed ${T.border}`,
                  display: "flex", alignItems: "center", justifyContent: "center"
                }}>
                  <Camera size={20} style={{ color: T.txtM }} />
                </div>
              )}
            </div>
            <p style={{ fontSize: "12px", color: T.txtM }}>{uploadedPhotos.length}/5 photos Â· Click to add more</p>
          </>
        )}
      </div>

      <div style={{ background: T.bgCard, border: `1px solid ${T.border}`, borderRadius: "12px", padding: "16px", marginBottom: "24px" }}>
        <p style={{ fontSize: "12px", fontWeight: 600, color: T.txt, marginBottom: "10px" }}>Tips for best results:</p>
        <div style={{ display: "flex", alignItems: "flex-start", gap: "10px", marginBottom: "10px", padding: "10px", background: T.warm + "10", borderRadius: "8px", border: `1px solid ${T.warm}25` }}>
          <Camera size={18} style={{ color: T.warm, flexShrink: 0, marginTop: "1px" }} />
          <div>
            <p style={{ fontSize: "13px", color: T.warm, fontWeight: 600, marginBottom: "2px" }}>Include a headstock close-up</p>
            <p style={{ fontSize: "12px", color: T.txt2, lineHeight: 1.5 }}>The brand logo on the headstock is the #1 identifier. A close-up helps the AI distinguish boutique builders (Nash, Suhr, etc.) from major brands.</p>
          </div>
        </div>
        <ul style={{ fontSize: "13px", color: T.txt2, lineHeight: 1.8, paddingLeft: "20px", margin: 0 }}>
          <li>Full body shot in good lighting</li>
          <li>Serial number (if visible)</li>
          <li>Close-up of pickups/hardware</li>
        </ul>
      </div>

      <Button
        onClick={handleAnalyze}
        disabled={uploadedPhotos.length === 0}
        style={{ width: "100%", padding: "12px" }}
      >
        <Sparkles size={16} style={{ marginRight: "8px", display: "inline" }} />
        Analyze with AI
      </Button>
    </div>
  );

  // --- RESULTS PHASE ---
  const renderResults = () => (
    <div>
      <h2 style={{ fontFamily: "'Playfair Display', serif", fontSize: "28px", fontWeight: 600, color: T.txt, marginBottom: "8px" }}>
        AI Results
      </h2>
      <p style={{ color: T.txt2, marginBottom: "28px", fontSize: "15px" }}>
        Review the AI's findings. Edit any fields that need adjustment.
      </p>

      {/* Uploaded photos strip */}
      <div style={{ display: "flex", gap: "8px", marginBottom: "20px", overflowX: "auto", paddingBottom: "4px" }}>
        {uploadedPhotos.map((p, i) => (
          <img key={i} src={p.preview} alt={`Upload ${i + 1}`}
            style={{ width: "56px", height: "56px", borderRadius: "8px", objectFit: "cover", border: `2px solid ${i === 0 ? T.warm : T.border}`, flexShrink: 0 }}
          />
        ))}
      </div>

      {/* Overall confidence */}
      <div style={{ background: T.bgCard, border: `1px solid ${T.border}`, borderRadius: "12px", padding: "20px", marginBottom: "24px" }}>
        <ConfidenceMeter value={results.confidence} size="large" />
      </div>

      {/* Brand correction banner */}
      <BrandCorrectionBanner
        currentBrand={results.brand?.value}
        onCorrect={(newBrand) => setResults(prev => ({ ...prev, brand: { ...prev.brand, value: newBrand, confidence: 1.0 } }))}
      />

      {/* Results card */}
      <div style={{ background: T.bgCard, border: `1px solid ${T.border}`, borderRadius: "12px", padding: "20px", marginBottom: "24px" }}>
        <h3 style={{ fontSize: "14px", fontWeight: 600, color: T.txt, marginBottom: "16px" }}>Identified Fields</h3>
        <AIResultField label="Brand" result={results.brand} onEdit={v => setResults({ ...results, brand: { ...results.brand, value: v } })} />
        <AIResultField label="Model" result={results.model} onEdit={v => setResults({ ...results, model: { ...results.model, value: v } })} />
        <AIResultField label="Year" result={results.year} onEdit={v => setResults({ ...results, year: { ...results.year, value: v } })} />
        <AIResultField label="Body Type" result={results.bodyType} onEdit={v => setResults({ ...results, bodyType: { ...results.bodyType, value: v } })} />
        <AIResultField label="Top Wood" result={results.topWood} onEdit={v => setResults({ ...results, topWood: { ...results.topWood, value: v } })} />
        <AIResultField label="Body Wood" result={results.bodyWood} onEdit={v => setResults({ ...results, bodyWood: { ...results.bodyWood, value: v } })} />
        <AIResultField label="Finish" result={results.finish} onEdit={v => setResults({ ...results, finish: { ...results.finish, value: v } })} />
        <AIResultField label="Pickups" result={results.pickups} onEdit={v => setResults({ ...results, pickups: { ...results.pickups, value: v } })} />
        <AIResultField label="Bridge" result={results.bridge} onEdit={v => setResults({ ...results, bridge: { ...results.bridge, value: v } })} />
      </div>

      {/* Analysis source message */}
      {analysisSource === "empty" && (
        <div style={{ background: "#3B82F615", border: `1px solid #3B82F640`, borderRadius: "12px", padding: "16px", marginBottom: "16px" }}>
          <p style={{ fontSize: "13px", color: "#3B82F6", fontWeight: 600, marginBottom: "6px" }}>
            <Info size={14} style={{ display: "inline", marginRight: "6px", verticalAlign: "text-bottom" }} />
            AI Analysis Unavailable
          </p>
          <p style={{ fontSize: "12px", color: T.txt2, lineHeight: 1.6 }}>
            The AI backend couldn't identify your guitar. Please fill in the details manually. We're working to improve guitar identification â€” your feedback helps!
          </p>
        </div>
      )}

      {analysisSource === "smart-fallback" && (
        <div style={{ background: "#8B5CF615", border: `1px solid #8B5CF640`, borderRadius: "12px", padding: "16px", marginBottom: "16px" }}>
          <p style={{ fontSize: "13px", color: "#D8B4FE", fontWeight: 600, marginBottom: "6px" }}>
            <AlertTriangle size={14} style={{ display: "inline", marginRight: "6px", verticalAlign: "text-bottom" }} />
            Partial Match from Filename
          </p>
          <p style={{ fontSize: "12px", color: T.txt2, lineHeight: 1.6 }}>
            We detected some info from your photo names. Please review and complete all fields before continuing.
          </p>
        </div>
      )}

      {/* AI notes (from real analysis) */}
      {aiNotes && analysisSource === "real" && (
        <div style={{ background: T.bgDeep, border: `1px solid ${T.borderAcc}`, borderRadius: "12px", padding: "16px", marginBottom: "16px" }}>
          <p style={{ fontSize: "12px", fontWeight: 600, color: T.amber, marginBottom: "6px" }}>
            <FileText size={14} style={{ display: "inline", marginRight: "6px", verticalAlign: "text-bottom" }} />
            AI Notes
          </p>
          <p style={{ fontSize: "13px", color: T.txt2, lineHeight: 1.6 }}>{aiNotes}</p>
        </div>
      )}

      {/* Note about review */}
      <div style={{ background: T.bgDeep, border: `1px solid ${T.border}`, borderRadius: "12px", padding: "16px", marginBottom: "24px" }}>
        <p style={{ fontSize: "12px", color: T.txtM, lineHeight: 1.6 }}>
          <Shield size={14} style={{ display: "inline", marginRight: "6px", verticalAlign: "text-bottom" }} />
          {analysisSource === "real"
            ? "AI identification is in beta. Review and correct the results before publishing. Your photos have been uploaded and will be attached to the guitar entry."
            : "Please review and complete all fields. Your photos will be attached to the guitar entry when you finish."}
        </p>
      </div>

      <div style={{ display: "flex", gap: "12px" }}>
        <Button variant="secondary" onClick={resetAll}>
          <ArrowLeft size={14} style={{ marginRight: "6px", display: "inline" }} />
          Upload Different
        </Button>
        <Button onClick={handleContinueToForm} style={{ flex: 1 }}>
          Continue to Full Form
          <ArrowRight size={14} style={{ marginLeft: "6px", display: "inline" }} />
        </Button>
      </div>
    </div>
  );

  // --- FAILED PHASE ---
  const renderFailed = () => (
    <div>
      <h2 style={{ fontFamily: "'Playfair Display', serif", fontSize: "28px", fontWeight: 600, color: T.txt, marginBottom: "8px" }}>
        Could Not Identify Guitar
      </h2>
      <p style={{ color: T.txt2, marginBottom: "28px", fontSize: "15px" }}>
        The AI had trouble analyzing these images. Please try again with clearer photos or use manual entry.
      </p>

      <div style={{ background: T.bgCard, border: `1px dashed ${T.border}`, borderRadius: "12px", padding: "24px", textAlign: "center", marginBottom: "24px" }}>
        <AlertTriangle size={40} style={{ color: "#F87171", marginBottom: "12px" }} />
        <p style={{ fontSize: "14px", color: T.txt, marginBottom: "8px" }}>Analysis Failed</p>
        <p style={{ fontSize: "13px", color: T.txt2 }}>
          {failReason || "Try uploading different angles or better-lit photos"}
        </p>
      </div>

      <div style={{ display: "flex", gap: "12px" }}>
        <Button variant="secondary" onClick={resetAll} style={{ flex: 1 }}>
          Try Again
        </Button>
        <Button onClick={handleEnterManually} style={{ flex: 1 }}>
          Enter Manually
        </Button>
      </div>
    </div>
  );

  return (
    <div style={{ flex: 1 }}>
      <div style={{ maxWidth: "680px", margin: "0 auto", padding: "40px 24px" }}>
        {phase === "upload" && renderUpload()}
        {phase === "processing" && <ProcessingAnimation progress={progress} stage={stage} />}
        {phase === "results" && renderResults()}
        {phase === "failed" && renderFailed()}
      </div>
    </div>
  );
}

// ============================================================
// MAIN COMPONENT - TAB SWITCHING
// ============================================================
export default function TWNGAddGuitar() {
  const [mode, setMode] = useState("manual"); // manual | magic
  const [prefillData, setPrefillData] = useState(null);

  // Called when Magic Add analysis is complete â€” switch to manual form with pre-filled data
  const handleMagicComplete = (data) => {
    setPrefillData(data);
    setMode("manual");
  };

  // Switch to manual mode without any pre-filled data
  const handleSwitchManual = () => {
    setPrefillData(null);
    setMode("manual");
  };

  // When user switches modes via toggle, clear prefill data
  const handleModeSwitch = (newMode) => {
    if (newMode !== mode) {
      setPrefillData(null);
      setMode(newMode);
    }
  };

  return (
    <div style={{
      background: T.bgDeep, color: T.txt, fontFamily: "'DM Sans', sans-serif",
      minHeight: "100vh", display: "flex", flexDirection: "column"
    }}>
      {/* Google Fonts */}
      <link rel="preconnect" href="https://fonts.googleapis.com" />
      <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,600;0,700;1,400&family=DM+Sans:wght@400;500;600&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet" />
      <style>{`* { box-sizing: border-box; margin: 0; } body { background: #0C0A09; } ::-webkit-scrollbar { display: none; }`}</style>

      {/* Header */}
      <header style={{
        position: "sticky", top: 0, zIndex: 40, background: T.bgDeep + "E6",
        backdropFilter: "blur(20px)", borderBottom: `1px solid ${T.border}`
      }}>
        <div style={{
          maxWidth: "720px", margin: "0 auto", padding: "0 24px",
          display: "flex", alignItems: "center", justifyContent: "center", height: "64px"
        }}>
          {/* Mode toggle */}
          <div style={{ display: "flex", gap: "4px", background: T.bgCard, padding: "5px", borderRadius: "12px", border: `1px solid ${T.border}` }}>
            {[
              { key: "manual", label: "Add Guitar (Manual)", icon: "âœï¸" },
              { key: "magic", label: "Magic Add (AI)", icon: "âœ¨" }
            ].map(m => (
              <button
                key={m.key}
                onClick={() => handleModeSwitch(m.key)}
                style={{
                  padding: "10px 24px", borderRadius: "8px", fontSize: "14px", fontWeight: 600,
                  border: mode === m.key ? "none" : `1px solid transparent`,
                  background: mode === m.key ? T.warm : "transparent",
                  color: mode === m.key ? T.bgDeep : T.txt2,
                  cursor: "pointer", transition: "all 0.2s",
                  letterSpacing: "0.01em",
                }}
              >
                {m.icon} {m.label}
              </button>
            ))}
          </div>
        </div>
      </header>

      {/* Content */}
      <main style={{ flex: 1, overflow: "auto" }}>
        {mode === "manual"
          ? <AddGuitarManual key={prefillData ? 'prefilled' : 'blank'} initialData={prefillData} />
          : <MagicAddAI onComplete={handleMagicComplete} onSwitchManual={handleSwitchManual} />
        }
      </main>
    </div>
  );
}
